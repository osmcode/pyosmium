{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>pyosmium is a library to efficiently read and process OpenStreetMap data files. It is based on the osmium library for reading and writing data and adds convenience functions that allow you to set up fast processing pipelines in Pythons that can handle even planet-sized data.</p> <p>This manual comes in three parts:</p> <ul> <li>the User Manual introduces the concepts and functionalities of pyosmium</li> <li>the Cookbook shows how to solve typical OSM data processing challenges with pyosmium</li> <li>the Reference contains a complete list of classes and functions.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The recommended way to install pyosmium is via pip:</p> <pre><code>pip install osmium\n</code></pre> <p>Binary wheels are provided for all actively maintained Python versions on Linux, MacOS and Windows 64bit.</p>"},{"location":"#installing-from-source","title":"Installing from Source","text":"<p>To compile pyosmium from source or when installing it from the source wheel, the following additional dependencies need to be available:</p> <ul> <li>libosmium &gt;= 2.16.0</li> <li>protozero</li> <li>cmake</li> <li>Pybind11 &gt;= 2.2</li> <li>expat</li> <li>libz</li> <li>libbz2</li> <li>Boost variant and iterator &gt;= 1.41</li> <li>Python Requests</li> <li>Python setuptools</li> <li>a recent C++ compiler (Clang 3.4+, GCC 4.8+)</li> </ul> <p>On Debian/Ubuntu-like systems, the following command installs all required packages:</p> <pre><code>sudo apt-get install python3-dev build-essential cmake libboost-dev \\\n                     libexpat1-dev zlib1g-dev libbz2-dev\n</code></pre> <p>libosmium, protozero and pybind11 are shipped with the source wheel. When building from source, you need to download the source code and put it in the subdirectory 'contrib'. Alternatively, if you want to put the sources somewhere else, point pyosmium to the source code location by setting the CMake variables <code>LIBOSMIUM_PREFIX</code>, <code>PROTOZERO_PREFIX</code> and <code>PYBIND11_PREFIX</code> respectively.</p> <p>To compile and install the bindings, run</p> <pre><code>pip install [--user] .\n</code></pre>"},{"location":"cookbooks/","title":"Overview","text":"<p>This section presents practical examples and use cases, where pyosmium can come in handy. Each cookbook comes with three sections:</p> <ul> <li>Task explains what should be achieved</li> <li>Quick Solution gives you a ready to use script that solves the task</li> <li>Background explains in detail what happens in the script and why it   is done the way it is done. This should help you to write similar scripts   on your own.</li> </ul> <p>All cookbooks are available as Jupiter notebooks in the pyosmium source tree</p>"},{"location":"reference/","title":"Overview","text":"<p>This section lists all functions and classes that pyosmium implements for reference.</p>"},{"location":"reference/#basic-pyosmium-types","title":"Basic pyosmium types","text":""},{"location":"reference/#osmium.BaseHandler","title":"<code>osmium.BaseHandler</code>","text":"<p>Base class for all native handler functions in pyosmium. Any class that derives from this class can be used for parameters that need a handler-like object.</p>"},{"location":"reference/#osmium.BaseFilter","title":"<code>osmium.BaseFilter</code>","text":"<p>               Bases: <code>osmium._osmium.BaseHandler</code></p> <p>Base class for all native filter functions in pyosmium. A filter is a handler that returns a boolean in the handler functions indicating if the object should pass the filter (False) or be dropped (True).</p>"},{"location":"reference/#osmium.BaseFilter.enable_for","title":"<code>enable_for(entities: osm_entity_bits) -&gt; None</code>","text":"<p>Set the OSM types this filter should be applied to. If an object has a type for which the filter is not enabled, the filter will be skipped completely. Or to put it in different words: every object for which the filter is not enabled, passes the filter automatically.</p>"},{"location":"reference/#handlerlike-objects","title":"<code>HandlerLike</code> objects","text":"<p>Many functions in pyosmium take handler-like objects as a parameter. Next to classes that derive from <code>BaseHandler</code> and <code>BaseFilter</code> you may also hand in any object that has one of the handler functions <code>node()</code>, <code>way()</code>, <code>relation()</code>, <code>area()</code>, or <code>changeset()</code> implemented.</p>"},{"location":"user_manual/","title":"Overview","text":"<p>This user manual gives you an introduction on how to process OpenStreetMap data</p> <ul> <li>First Steps   gives an overview of the OSM data model and how pyosmium processes the data</li> <li>Extracting Object Data   looks into what data is contained inside an OSM object</li> <li>Working with Geometries   explains how to create points, line strings and polygons for OSM objects</li> <li>Working with Filters   introduces how to select the right data to process</li> <li>Working with Handlers   shows how to work with a callback-based approach for processing data</li> <li>Writing data   explains how to create a new OSM file</li> <li>Input Formats and Other Sources   looks into other sources for OSM data than files</li> <li>Working With Change Files   explores how to handle OSM diff files with updates</li> <li>Working with History Files   looks into the specifics of OSM files containing multiple versions of an object</li> <li>Replication Tools   lists the means how to obtain OSM update data with pyosmium</li> </ul> <p>pyosmium builds on the fast and efficient libosmium library. It borrows many of its concepts from libosmium. For more in-depth information, you might also want to consult the libosmium manual.</p>"},{"location":"cookbooks/Adding-Node-Infos-To-Boundaries/","title":"Adding Place Node Information to Boundary Relations","text":"In\u00a0[1]: Copied! <pre>import osmium\nfrom dataclasses import dataclass\nimport json\n</pre> import osmium from dataclasses import dataclass import json In\u00a0[2]: Copied! <pre>@dataclass\nclass PlaceInfo:\n    id: int\n    tags: dict[str, str]\n    coords: tuple[float, float]\n\ngeojsonfab = osmium.geom.GeoJSONFactory()\n\nclass BoundaryHandler(osmium.SimpleHandler):\n    def __init__(self, outfile):\n        self.places = {}\n        self.outfile = outfile\n        # write the header of the geojson file\n        self.outfile.write('{\"type\": \"FeatureCollection\", \"features\": [')\n        # This is just to make sure, we place the commas on the right place.\n        self.delim = ''\n\n    def finish(self):\n        self.outfile.write(']}')\n\n    def node(self, n):\n        self.places[n.tags['wikidata']] = PlaceInfo(n.id, dict(n.tags), (n.location.lon, n.location.lat))\n    \n    def area(self, a):\n        # Find the corresponding place node\n        place = self.places.get(a.tags.get('wikidata', 'not found'), None)\n        # Geojsonfab creates a string with the geojson geometry.\n        # Convert to a Python object to make it easier to add data.\n        geom = json.loads(geojsonfab.create_multipolygon(a))\n        if geom:\n            # print the array delimiter, if necessary\n            self.outfile.write(self.delim)\n            self.delim = ','\n\n            tags = dict(a.tags)\n            # add the place information to the propoerties\n            if place is not None:\n                tags['place_node:id'] = str(place.id)\n                tags['place_node:lat'] = str(place.coords[1])\n                tags['place_node:lon'] = str(place.coords[0])\n                for k, v in place.tags.items():\n                    tags['place_node:tags:' + k] = v\n            # And wrap everything in proper GeoJSON.\n            feature = {'type': 'Feature', 'geometry': geom, 'properties': dict(tags)}\n            self.outfile.write(json.dumps(feature))\n\n# We are interested in boundary relations that make up areas and not in ways at all.\nfilters = [osmium.filter.KeyFilter('place').enable_for(osmium.osm.NODE),\n           osmium.filter.KeyFilter('wikidata').enable_for(osmium.osm.NODE),\n           osmium.filter.EntityFilter(~osmium.osm.WAY),\n           osmium.filter.TagFilter(('boundary', 'administrative')).enable_for(osmium.osm.AREA | osmium.osm.RELATION)]\n\nwith open('../data/out/boundaries.geojson', 'w') as outf:\n    handler = BoundaryHandler(outf)\n    handler.apply_file('../data/liechtenstein.osm.pbf', filters=filters)\n    handler.finish()\n</pre> @dataclass class PlaceInfo:     id: int     tags: dict[str, str]     coords: tuple[float, float]  geojsonfab = osmium.geom.GeoJSONFactory()  class BoundaryHandler(osmium.SimpleHandler):     def __init__(self, outfile):         self.places = {}         self.outfile = outfile         # write the header of the geojson file         self.outfile.write('{\"type\": \"FeatureCollection\", \"features\": [')         # This is just to make sure, we place the commas on the right place.         self.delim = ''      def finish(self):         self.outfile.write(']}')      def node(self, n):         self.places[n.tags['wikidata']] = PlaceInfo(n.id, dict(n.tags), (n.location.lon, n.location.lat))          def area(self, a):         # Find the corresponding place node         place = self.places.get(a.tags.get('wikidata', 'not found'), None)         # Geojsonfab creates a string with the geojson geometry.         # Convert to a Python object to make it easier to add data.         geom = json.loads(geojsonfab.create_multipolygon(a))         if geom:             # print the array delimiter, if necessary             self.outfile.write(self.delim)             self.delim = ','              tags = dict(a.tags)             # add the place information to the propoerties             if place is not None:                 tags['place_node:id'] = str(place.id)                 tags['place_node:lat'] = str(place.coords[1])                 tags['place_node:lon'] = str(place.coords[0])                 for k, v in place.tags.items():                     tags['place_node:tags:' + k] = v             # And wrap everything in proper GeoJSON.             feature = {'type': 'Feature', 'geometry': geom, 'properties': dict(tags)}             self.outfile.write(json.dumps(feature))  # We are interested in boundary relations that make up areas and not in ways at all. filters = [osmium.filter.KeyFilter('place').enable_for(osmium.osm.NODE),            osmium.filter.KeyFilter('wikidata').enable_for(osmium.osm.NODE),            osmium.filter.EntityFilter(~osmium.osm.WAY),            osmium.filter.TagFilter(('boundary', 'administrative')).enable_for(osmium.osm.AREA | osmium.osm.RELATION)]  with open('../data/out/boundaries.geojson', 'w') as outf:     handler = BoundaryHandler(outf)     handler.apply_file('../data/liechtenstein.osm.pbf', filters=filters)     handler.finish() In\u00a0[3]: Copied! <pre>@dataclass\nclass PlaceInfo:\n    id: int\n    tags: dict[str, str]\n    coords: tuple[float, float]\n</pre> @dataclass class PlaceInfo:     id: int     tags: dict[str, str]     coords: tuple[float, float] <p>This class can now be filled from the OSM file:</p> In\u00a0[4]: Copied! <pre>class PlaceNodeReader:\n\n    def __init__(self):\n        self.places = {}\n\n    def node(self, n):\n        self.places[n.tags['wikidata']] = PlaceInfo(n.id, dict(n.tags), (n.location.lon, n.location.lat))\n\nreader = PlaceNodeReader()\n\nosmium.apply('../data/liechtenstein.osm.pbf',\n             osmium.filter.KeyFilter('place').enable_for(osmium.osm.NODE),\n             osmium.filter.KeyFilter('wikidata').enable_for(osmium.osm.NODE),\n             reader)\n\nprint(f\"{len(reader.places)} places cached.\")\n</pre> class PlaceNodeReader:      def __init__(self):         self.places = {}      def node(self, n):         self.places[n.tags['wikidata']] = PlaceInfo(n.id, dict(n.tags), (n.location.lon, n.location.lat))  reader = PlaceNodeReader()  osmium.apply('../data/liechtenstein.osm.pbf',              osmium.filter.KeyFilter('place').enable_for(osmium.osm.NODE),              osmium.filter.KeyFilter('wikidata').enable_for(osmium.osm.NODE),              reader)  print(f\"{len(reader.places)} places cached.\") <pre>29 places cached.\n</pre> <p>We use the <code>osmium.apply()</code> function here with a handler instead of a FileProcessor. The two approaches are equivalent. Which one you choose, depends on your personal taste. FileProcessor loops are less verbose and quicker to write. Handlers tend to yield more readable code when you want to do very different things with the different kinds of objects.</p> <p>As you can see in the code, it is entirely possible to use filter functions with the apply() functions. In our case, the filters make sure that only objects pass which have a <code>place</code> tag and a <code>wikidata</code> tag. This leaves exactly the objects we need already, so no further processing needed in the handler callback.</p> <p>Next the relations need to be read. Relations can be huge, so we don't want to cache them but write them directly out into a file. If we want to create a geojson file, then we need the geometry of the relation in geojson format. Getting geojson format itself is easy. Pyosmium has a converter built-in for this, the GeoJSONFactory:</p> In\u00a0[5]: Copied! <pre>geojsonfab = osmium.geom.GeoJSONFactory()\n</pre> geojsonfab = osmium.geom.GeoJSONFactory() <p>The factory only needs to be instantiated once and can then be used globally.</p> <p>To get the polygon from a relation, the special area handler is needed. It is easiest to invoke by writing a SimpleHandler class with an <code>area()</code> callback. When <code>apply_file()</code> is called on the handler, it will take the necessary steps in the background to build the polygon geometries.</p> In\u00a0[6]: Copied! <pre>class BoundaryHandler(osmium.SimpleHandler):\n    def __init__(self, places, outfile):\n        self.places = places\n        self.outfile = outfile\n        # write the header of the geojson file\n        self.outfile.write('{\"type\": \"FeatureCollection\", \"features\": [')\n        # This is just to make sure, we place the commas on the right place.\n        self.delim = ''\n\n    def finish(self):\n        self.outfile.write(']}')\n\n    def area(self, a):\n        # Find the corresponding place node\n        place = self.places.get(a.tags.get('wikidata', 'not found'), None)\n        # Geojsonfab creates a string with the geojson geometry.\n        # Convert to a Python object to make it easier to add data.\n        geom = json.loads(geojsonfab.create_multipolygon(a))\n        if geom:\n            # print the array delimiter, if necessary\n            self.outfile.write(self.delim)\n            self.delim = ','\n\n            tags = dict(a.tags)\n            # add the place information to the propoerties\n            if place is not None:\n                tags['place_node:id'] = str(place.id)\n                tags['place_node:lat'] = str(place.coords[1])\n                tags['place_node:lon'] = str(place.coords[0])\n                for k, v in place.tags.items():\n                    tags['place_node:tags:' + k] = v\n            # And wrap everything in proper GeoJSON.\n            feature = {'type': 'Feature', 'geometry': geom, 'properties': dict(tags)}\n            self.outfile.write(json.dumps(feature))\n\n# We are interested in boundary relations that make up areas and not in ways at all.\nfilters = [osmium.filter.EntityFilter(osmium.osm.RELATION | osmium.osm.AREA),\n           osmium.filter.TagFilter(('boundary', 'administrative'))]\n\nwith open('../data/out/boundaries.geojson', 'w') as outf:\n    handler = BoundaryHandler(reader.places, outf)\n    handler.apply_file('../data/liechtenstein.osm.pbf', filters=filters)\n    handler.finish()\n</pre> class BoundaryHandler(osmium.SimpleHandler):     def __init__(self, places, outfile):         self.places = places         self.outfile = outfile         # write the header of the geojson file         self.outfile.write('{\"type\": \"FeatureCollection\", \"features\": [')         # This is just to make sure, we place the commas on the right place.         self.delim = ''      def finish(self):         self.outfile.write(']}')      def area(self, a):         # Find the corresponding place node         place = self.places.get(a.tags.get('wikidata', 'not found'), None)         # Geojsonfab creates a string with the geojson geometry.         # Convert to a Python object to make it easier to add data.         geom = json.loads(geojsonfab.create_multipolygon(a))         if geom:             # print the array delimiter, if necessary             self.outfile.write(self.delim)             self.delim = ','              tags = dict(a.tags)             # add the place information to the propoerties             if place is not None:                 tags['place_node:id'] = str(place.id)                 tags['place_node:lat'] = str(place.coords[1])                 tags['place_node:lon'] = str(place.coords[0])                 for k, v in place.tags.items():                     tags['place_node:tags:' + k] = v             # And wrap everything in proper GeoJSON.             feature = {'type': 'Feature', 'geometry': geom, 'properties': dict(tags)}             self.outfile.write(json.dumps(feature))  # We are interested in boundary relations that make up areas and not in ways at all. filters = [osmium.filter.EntityFilter(osmium.osm.RELATION | osmium.osm.AREA),            osmium.filter.TagFilter(('boundary', 'administrative'))]  with open('../data/out/boundaries.geojson', 'w') as outf:     handler = BoundaryHandler(reader.places, outf)     handler.apply_file('../data/liechtenstein.osm.pbf', filters=filters)     handler.finish() <p>There are two things you should keep in mind, when working with areas:</p> <ol> <li>When the area handler is invoked, the input file is always read twice. The first pass checks the relations and find out which ways it contains. The second pass assembles all necessary ways and builds the geometries.</li> <li>The area handler automatically enables caching of node locations. You don't need to worry about this when working with small files like our Liechtenstein example. For larger files of continent- or planet-size, the node cache can become quite large. You should read up about the alternative implementations that can write out the node cache on disk to save RAM.</li> </ol> <p>This is already it. In the long version, we have read the input file twice, once to get the nodes and in the second pass to get the relations. This is not really necessary because the nodes come always before the relations in the file. The quick solution shows how to combine both handlers to create the geojson file in a single pass. The only part to pay attention to is the use of filters. Given that we have very different filters for nodes and relations, it is important to call <code>enable_for()</code> with the correct OSM type.</p>"},{"location":"cookbooks/Adding-Node-Infos-To-Boundaries/#adding-place-node-information-to-boundary-relations","title":"Adding Place Node Information to Boundary Relations\u00b6","text":"<p>How to merge information from different OSM objects.</p>"},{"location":"cookbooks/Adding-Node-Infos-To-Boundaries/#task","title":"Task\u00b6","text":"<p>Administrative areas often represented with two different objects in OSM: a node describes the central point and a relation that contains all the ways that make up the boundary. The task is to find all administrative boundaries and their matching place nodes and output both togther in a geojson file. Relations and place nodes should be matched when they have the same wikidata tag.</p>"},{"location":"cookbooks/Adding-Node-Infos-To-Boundaries/#quick-solution","title":"Quick solution\u00b6","text":""},{"location":"cookbooks/Adding-Node-Infos-To-Boundaries/#background","title":"Background\u00b6","text":"<p>Whenever you want to look at more than one OSM object at the time, you need to cache objects. Before starting such a task, it is always worth taking a closer look at the objects of interest. Find out how many candidates there are for you to look at and save and how large these objects are. There are always multiple ways to cache your data. Sometimes, when the number of candidates is really large, it is even more sensible to reread the file instead of caching the information.</p> <p>For the boundary problem, the calculation is relatively straightforward. Boundary relations are huge, so we do not want to cache them if it can somehow be avoided. That means we need to cache the place nodes. A quick look at TagInfo tells us that there are about 7 million place nodes in the OSM planet. That is not a lot in the grand scheme of things. We could just read them all into memory and be done with it. It is still worth to take a closer look. The place nodes are later matched up by their <code>wikidata</code> tag. Looking into the TagInfo combinations table, only 10% of the place nodes have such a tag. That leaves 850.000 nodes to cache. Much better!</p> <p>Next we need to consider what information actually needs caching. In our case we want it all: the ID, the tags and the coordinates of the node. This information needs to be copied out of the node. You cannot just cache the entire node. Pyosmium won't let you do this because it wants to get rid of it as soon as the handler has seen it. Lets create a dataclass to receive the information we need:</p>"},{"location":"cookbooks/Adding-Route-Info-To-Ways/","title":"Adding Relation Information to Member Ways","text":"In\u00a0[1]: Copied! <pre>import osmium\nfrom collections import defaultdict\n</pre> import osmium from collections import defaultdict In\u00a0[2]: Copied! <pre>fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.RELATION)\\\n           .with_filter(osmium.filter.TagFilter(('type', 'route')))\\\n           .with_filter(osmium.filter.TagFilter(('route', 'bicycle')))\n\nroutes = {}\nmembers = defaultdict(list)\nfor rel in fp:\n    routes[rel.id] = (rel.tags.get('name', ''), rel.tags.get('ref', ''))\n    \n    for member in rel.members:\n        if member.type == 'w':\n            members[member.ref].append(rel.id)\n\nwith osmium.SimpleWriter('../data/out/cycling.osm.opl', overwrite=True) as writer:\n    fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\\n               .with_filter(osmium.filter.IdFilter(members.keys()).enable_for(osmium.osm.WAY))\\\n               .handler_for_filtered(writer)\n\n    for way in fp:\n        assert all(i in routes for i in members[way.id])\n        # To add tags, first convert the tags into a Python dictionary.\n        tags = dict(way.tags)\n        tags['cycle_route:name'] = '|'.join(routes[i][0] for i in members[way.id])[:255]\n        tags['cycle_route:ref'] = '|'.join(routes[i][1] for i in members[way.id])[:255]\n        writer.add(way.replace(tags=tags))\n</pre> fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.RELATION)\\            .with_filter(osmium.filter.TagFilter(('type', 'route')))\\            .with_filter(osmium.filter.TagFilter(('route', 'bicycle')))  routes = {} members = defaultdict(list) for rel in fp:     routes[rel.id] = (rel.tags.get('name', ''), rel.tags.get('ref', ''))          for member in rel.members:         if member.type == 'w':             members[member.ref].append(rel.id)  with osmium.SimpleWriter('../data/out/cycling.osm.opl', overwrite=True) as writer:     fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\                .with_filter(osmium.filter.IdFilter(members.keys()).enable_for(osmium.osm.WAY))\\                .handler_for_filtered(writer)      for way in fp:         assert all(i in routes for i in members[way.id])         # To add tags, first convert the tags into a Python dictionary.         tags = dict(way.tags)         tags['cycle_route:name'] = '|'.join(routes[i][0] for i in members[way.id])[:255]         tags['cycle_route:ref'] = '|'.join(routes[i][1] for i in members[way.id])[:255]         writer.add(way.replace(tags=tags)) In\u00a0[3]: Copied! <pre>fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.RELATION)\\\n           .with_filter(osmium.filter.TagFilter(('type', 'route')))\\\n           .with_filter(osmium.filter.TagFilter(('route', 'bicycle')))\n\nroutes = {}\nfor rel in fp:\n    routes[rel.id] = (rel.tags.get('name', ''), rel.tags.get('ref', ''))\n\nf\"Found {len(routes)} routes.\"\n</pre> fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.RELATION)\\            .with_filter(osmium.filter.TagFilter(('type', 'route')))\\            .with_filter(osmium.filter.TagFilter(('route', 'bicycle')))  routes = {} for rel in fp:     routes[rel.id] = (rel.tags.get('name', ''), rel.tags.get('ref', ''))  f\"Found {len(routes)} routes.\" Out[3]: <pre>'Found 13 routes.'</pre> <p>It is safe to restrict the FileProcessor to the RELATION type because we are only interested in relations and don't need geometry information. A cycling route comes with two mandatory tags in OSM, <code>type=route</code> and <code>route=bicycle</code>. To filter for relations that have both tags in them, simply chain two TagFilters. Don't just use a single filter with two tags like this: <code>osmium.filter.TagFilter(('type', 'route'), ('route', 'bicycle'))</code>.  This would filter for relation that have either the route tag or the type tag. Not exactly what we want.</p> <p>For each relation that goes through the filter, save the information needed. Resist the temptation to simply save the complete relation. For one thing, a single relation can become quite large. But more importantly, pyosmium will not allow you to access the object anymore once the end of the loop iteraton is reached. You only ever see a temporary view of an object within the processing loop. You need to make a full copy of what you want to keep.</p> <p>Next we need to save the way-relation membership. This can be done in a simple dictionary. Just keep in mind that a single way can be in multiple relations. The member lookup needs to point to a list:</p> In\u00a0[4]: Copied! <pre>members = defaultdict(list)\nfor rel in fp:\n    for member in rel.members:\n        if member.type == 'w':\n            members[member.ref].append(rel.id)\n\nf\"Found {len(members)} ways that are part of a cycling relation.\"\n</pre> members = defaultdict(list) for rel in fp:     for member in rel.members:         if member.type == 'w':             members[member.ref].append(rel.id)  f\"Found {len(members)} ways that are part of a cycling relation.\" Out[4]: <pre>'Found 1023 ways that are part of a cycling relation.'</pre> <p>This is all the information needed to add the cycling information to the ways. Now we can write out the enhanced cycling info file. Only the ways with relations on them need to be modified. So we use an IdFilter to process only these ways and forward all other objects directly to the writer. This works just the same as in the Enhance-Tags cookbook:</p> In\u00a0[6]: Copied! <pre>with osmium.SimpleWriter('../data/out/cycling.osm.opl', overwrite=True) as writer:\n    fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\\n               .with_filter(osmium.filter.IdFilter(members.keys()).enable_for(osmium.osm.WAY))\\\n               .handler_for_filtered(writer)\n\n    for way in fp:\n        assert all(i in routes for i in members[way.id])\n        # To add tags, first convert the tags into a Python dictionary.\n        tags = dict(way.tags)\n        tags['cycle_route:name'] = '|'.join(routes[i][0] for i in members[way.id])[:255]\n        tags['cycle_route:ref'] = '|'.join(routes[i][1] for i in members[way.id])[:255]\n        writer.add(way.replace(tags=tags))\n</pre> with osmium.SimpleWriter('../data/out/cycling.osm.opl', overwrite=True) as writer:     fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\                .with_filter(osmium.filter.IdFilter(members.keys()).enable_for(osmium.osm.WAY))\\                .handler_for_filtered(writer)      for way in fp:         assert all(i in routes for i in members[way.id])         # To add tags, first convert the tags into a Python dictionary.         tags = dict(way.tags)         tags['cycle_route:name'] = '|'.join(routes[i][0] for i in members[way.id])[:255]         tags['cycle_route:ref'] = '|'.join(routes[i][1] for i in members[way.id])[:255]         writer.add(way.replace(tags=tags))"},{"location":"cookbooks/Adding-Route-Info-To-Ways/#adding-relation-information-to-member-ways","title":"Adding Relation Information to Member Ways\u00b6","text":"<p>How to transfer information from a relation to its members.</p>"},{"location":"cookbooks/Adding-Route-Info-To-Ways/#task","title":"Task\u00b6","text":"<p>Take the name and reference from all cycling routes and add it to the member ways of the route relation. Write out a new file with the added way information.</p>"},{"location":"cookbooks/Adding-Route-Info-To-Ways/#quick-solution","title":"Quick Solution\u00b6","text":""},{"location":"cookbooks/Adding-Route-Info-To-Ways/#background","title":"Background\u00b6","text":"<p>The objects in an OSM file are usually order by their type: first come nodes, then ways and finally relations. Given that pyosmium always scans files sequentially, it will be necessary to read the OSM file twice when you want to transfer information from relations to ways.</p> <p>The first pass is all about getting the information from the relations. There are two pieces of information to collect: the information about the relation itself and the information which relations a way belongs to. Lets start with collection the relation information:</p>"},{"location":"cookbooks/Enhance-Tags/","title":"Enhancing Tags in an OSM File","text":"In\u00a0[1]: Copied! <pre>import osmium\n</pre> import osmium In\u00a0[2]: Copied! <pre>with osmium.SimpleWriter('../data/out/renamed.pbf', overwrite=True) as writer:\n    fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\\n               .with_filter(osmium.filter.KeyFilter('name:fr'))\\\n               .handler_for_filtered(writer)\n\n    for obj in fp:\n        # start with a set of tags without name:fr\n        tags = {k: v for k, v in obj.tags if k != 'name:fr'}\n        # replace the name tag with the French version\n        tags['name'] = obj.tags['name:fr']\n        # Save the original if it exists.\n        if 'name' in obj.tags:\n            tags['name:local'] = obj.tags['name']\n        # Write back the object with the modified tags\n        writer.add(obj.replace(tags=tags))\n</pre> with osmium.SimpleWriter('../data/out/renamed.pbf', overwrite=True) as writer:     fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\                .with_filter(osmium.filter.KeyFilter('name:fr'))\\                .handler_for_filtered(writer)      for obj in fp:         # start with a set of tags without name:fr         tags = {k: v for k, v in obj.tags if k != 'name:fr'}         # replace the name tag with the French version         tags['name'] = obj.tags['name:fr']         # Save the original if it exists.         if 'name' in obj.tags:             tags['name:local'] = obj.tags['name']         # Write back the object with the modified tags         writer.add(obj.replace(tags=tags)) In\u00a0[3]: Copied! <pre>with osmium.SimpleWriter('../data/out/ele.osm.opl', overwrite=True) as writer:\n    for obj in osmium.FileProcessor('../data/liechtenstein.osm.pbf'):\n        if 'name:fr' in obj.tags:\n            tags = {k: v for k, v in obj.tags if k != 'name:fr'}\n            # ... do more stuff here\n            writer.add(obj.replace(tags=tags))\n        else:\n            writer.add(obj)\n</pre> with osmium.SimpleWriter('../data/out/ele.osm.opl', overwrite=True) as writer:     for obj in osmium.FileProcessor('../data/liechtenstein.osm.pbf'):         if 'name:fr' in obj.tags:             tags = {k: v for k, v in obj.tags if k != 'name:fr'}             # ... do more stuff here             writer.add(obj.replace(tags=tags))         else:             writer.add(obj) <p>If you run this code snippet on a large OSM file, it will take a very long time to execute. Even though we only want to change a handful of objects (all objects that have a <code>name:fr</code> tag), the FileProcessor needs to present every single object to the Python code in the loop because every single objects needs to be written in the output file. We need a way to tell the FileProcessor to directly write out all the objects that we are not inspecting in the for loop. This can be done with the <code>handler_for_filtered()</code> function. It allows to define a handler for all the objects, the <code>with_filter()</code> handlers have rejected. The SimpleWriter class can itself function as a handler. By setting it as the handler for filtered objects, they will be directly passed to the writer.</p> <p>With the SimpleWriter as fallback in place, we can now create a FileProcessor that filters for objects with a <code>name:fr</code> tag:</p> In\u00a0[4]: Copied! <pre>with osmium.SimpleWriter('../data/out/buildings.opl', overwrite=True) as writer:\n    fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\\n               .with_filter(osmium.filter.KeyFilter('name:fr'))\\\n               .handler_for_filtered(writer)\n\n    for obj in fp:\n        print(f\"{obj.id} has the French name {obj.tags['name']}.\")\n</pre> with osmium.SimpleWriter('../data/out/buildings.opl', overwrite=True) as writer:     fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\                .with_filter(osmium.filter.KeyFilter('name:fr'))\\                .handler_for_filtered(writer)      for obj in fp:         print(f\"{obj.id} has the French name {obj.tags['name']}.\") <pre>1932181216 has the French name Vaduz.\n3696525426 has the French name Liechtenstein.\n9798887324 has the French name Schweizerisches Generalkonsulat.\n159018431 has the French name Rhein.\n424375869 has the French name Rhein.\n8497 has the French name Rhein-Route.\n12464 has the French name Seen-Route.\n16239 has the French name \u00d6sterreich.\n19664 has the French name Seen-Route - Etappe 9.\n27939 has the French name Cycling in Switzerland.\n51701 has the French name Schweiz/Suisse/Svizzera/Svizra.\n74942 has the French name Vorarlberg.\n102638 has the French name Rhein-Route - Etappe 3.\n102666 has the French name \u00d6sterreich - Schweiz.\n102877 has the French name \u00d6sterreich \u2014 Liechtenstein.\n123924 has the French name Rhein.\n302442 has the French name Schweizer Hauptstrassen.\n1155955 has the French name Liechtenstein.\n1550322 has the French name \u00d6sterreich \u2014 Schweiz / Suisse / Svizzera.\n1665395 has the French name Via Alpina Red.\n1686631 has the French name Graub\u00fcnden/Grischun/Grigioni.\n1687006 has the French name Sankt Gallen.\n2128682 has the French name R\u00e4tikon.\n2171555 has the French name EuroVelo 15 - Rheinradweg.\n2668952 has the French name European Union / Union Europ\u00e9enne / Europ\u00e4ische Union.\n2698607 has the French name Alps.\n11342353 has the French name Appenzeller Alpen.\n12579662 has the French name Via Alpina Green.\n12729625 has the French name Eurozone.\n13376469 has the French name Member States of the European Union / \u00c9tats members de l'Union europ\u00e9enne / Mitgliedstaaten der Europ\u00e4ischen Union.\n</pre> <p>If you run this piece of code, you will notice that suddenly all objects with a French name are missing from output file. This happens because once a file is presented to Python, the SimpleWriter object doesn't see it anymore. You have to explicitly call one of the 'add' functions of the SimpleWriter to write the modified object. So the full code is:</p> In\u00a0[5]: Copied! <pre>with osmium.SimpleWriter('../data/out/buildings.opl', overwrite=True) as writer:\n    fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\\n               .with_filter(osmium.filter.KeyFilter('name:fr'))\\\n               .handler_for_filtered(writer)\n    for obj in fp:\n        tags = {k: v for k, v in obj.tags if k != 'name:fr'}\n        # ... do more stuff here\n        writer.add(obj.replace(tags=tags))\n</pre> with osmium.SimpleWriter('../data/out/buildings.opl', overwrite=True) as writer:     fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\                .with_filter(osmium.filter.KeyFilter('name:fr'))\\                .handler_for_filtered(writer)     for obj in fp:         tags = {k: v for k, v in obj.tags if k != 'name:fr'}         # ... do more stuff here         writer.add(obj.replace(tags=tags))"},{"location":"cookbooks/Enhance-Tags/#enhancing-tags-in-an-osm-file","title":"Enhancing Tags in an OSM File\u00b6","text":"<p>How to modify selected objects in an OSM file.</p>"},{"location":"cookbooks/Enhance-Tags/#task","title":"Task\u00b6","text":"<p>Localise the OSM file for the French language: when a <code>name:fr</code> tag is available, replace the <code>name</code> tag with it and save the original name in <code>name:local</code>.</p>"},{"location":"cookbooks/Enhance-Tags/#quick-solution","title":"Quick solution\u00b6","text":""},{"location":"cookbooks/Enhance-Tags/#background","title":"Background\u00b6","text":"<p>To change selected tags in a file, it is necessary to read the file object by object, make changes as necessary and write back the data into a new file. This could be done with a simple FileProcessor (for reading the input file) that is combined with a SimpleWriter (for writing the output file):</p>"},{"location":"cookbooks/Filter-Data-By-Geometry/","title":"Filtering by Geometry","text":"In\u00a0[1]: Copied! <pre>import osmium\n</pre> import osmium In\u00a0[9]: Copied! <pre>with osmium.ForwardReferenceWriter('../data/out/centre.osm.pbf',\n                                   '../data/liechtenstein.osm.pbf', overwrite=True) as writer:\n    for obj in osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.NODE):\n        if osmium.geom.haversine_distance(osmium.osm.Location(9.52, 47.13), obj.location) &lt; 2000:\n            writer.add_node(obj)\n</pre> with osmium.ForwardReferenceWriter('../data/out/centre.osm.pbf',                                    '../data/liechtenstein.osm.pbf', overwrite=True) as writer:     for obj in osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.NODE):         if osmium.geom.haversine_distance(osmium.osm.Location(9.52, 47.13), obj.location) &lt; 2000:             writer.add_node(obj) In\u00a0[3]: Copied! <pre>with osmium.SimpleWriter('../data/out/centre.opl', overwrite=True) as writer:\n    for obj in osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.NODE):\n        if osmium.geom.haversine_distance(osmium.osm.Location(9.52, 47.13), obj.location) &lt; 2000:\n            writer.add_node(obj)\n</pre> with osmium.SimpleWriter('../data/out/centre.opl', overwrite=True) as writer:     for obj in osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.NODE):         if osmium.geom.haversine_distance(osmium.osm.Location(9.52, 47.13), obj.location) &lt; 2000:             writer.add_node(obj) <p>The FileProcessor reads the data and SimpleWriter writes the nodes out that we are interested in. Given that we are looking at nodes only, the FileProcessor can be restricted to that type. For one thing, this makes processing faster. For another it means, we don't have to explicitly check for the type of the object within the for loop. We can trust that only nodes will be returned. Checking if a node should be included in the output file is a simple matter of computing the distance between the target coordinates and the location of the node. pyosmium has a convenient function <code>haversine_distance()</code> for that. It computes the distance between two points in meters.</p> <p>This gives us a file with nodes. But what about the ways and relations? To find out which ones to include, we need to follow the forward references. Given the IDs of the nodes already included in the file, we need to find the ways which reference any of the nodes. And then we need to find relations which reference either nodes already included or one of the newly found ways. Luckily for us, OSM files are ordered by node, way and relations. So by the time the FileProcessor sees the first way, it will already have seen all the nodes and it can make an informed decision, if the way needs including or not. The same is true for relations. They are last in the file, so all the node and way members have been processed already. The situation is more complicated with relation members and nested relations. We leave those out for the moment.</p> <p>Given that nodes, ways and relations need to be handled differently and we need to carry quite a bit of state, it is easier to implement the forward referencing collector as a handler class:</p> In\u00a0[6]: Copied! <pre>class CoordHandler:\n    def __init__(self, coord, dist, writer):\n        self.center = osmium.osm.Location(*coord)\n        self.dist = dist\n        self.writer = writer\n        self.id_tracker = osmium.IdTracker()\n        \n    def node(self, n):\n        if osmium.geom.haversine_distance(self.center, n.location) &lt;= self.dist:\n            self.writer.add_node(n)\n            self.id_tracker.add_node(n.id)\n\n    def way(self, w):\n        if self.id_tracker.contains_any_references(w):\n            self.writer.add_way(w)\n            self.id_tracker.add_way(w.id)\n\n    def relation(self, r):\n        if self.id_tracker.contains_any_references(r):\n            self.writer.add_relation(r)\n</pre> class CoordHandler:     def __init__(self, coord, dist, writer):         self.center = osmium.osm.Location(*coord)         self.dist = dist         self.writer = writer         self.id_tracker = osmium.IdTracker()              def node(self, n):         if osmium.geom.haversine_distance(self.center, n.location) &lt;= self.dist:             self.writer.add_node(n)             self.id_tracker.add_node(n.id)      def way(self, w):         if self.id_tracker.contains_any_references(w):             self.writer.add_way(w)             self.id_tracker.add_way(w.id)      def relation(self, r):         if self.id_tracker.contains_any_references(r):             self.writer.add_relation(r) <p>The <code>IdTracker</code> class helps to keep track of all the objects that appear in the file. Every time a node or way is written, its ID is recorded. Tracking relation IDs would only be necessary for nested relations. The IDTracker gives us also a convenient function <code>contains_any_reference()</code> which checks if any of the IDs it is tracking is needed by the given object. If that is the case, the object needs to be written out.</p> <p>This is almost it. To get a referentially complete output file, we also need to add the objects that are referenced by the ways and relations we have added. This can be easily achieved by using the <code>BackReferenceWriter</code> in place of the <code>SimpleWriter</code>:</p> In\u00a0[7]: Copied! <pre>with osmium.BackReferenceWriter('../data/out/centre.osm.pbf', ref_src='../data/liechtenstein.osm.pbf', overwrite=True) as writer:\n    osmium.apply('../data/liechtenstein.osm.pbf', CoordHandler((9.52, 47.13), 2000, writer))\n</pre> with osmium.BackReferenceWriter('../data/out/centre.osm.pbf', ref_src='../data/liechtenstein.osm.pbf', overwrite=True) as writer:     osmium.apply('../data/liechtenstein.osm.pbf', CoordHandler((9.52, 47.13), 2000, writer)) <p>To learn more about adding backward references, have a look at the cookbook on Filtering By Tags.</p> <p>The <code>ForwardReferenceWriter</code> helps to automate most of what we have just done manually. It is a replacement for the <code>SimpleWriter</code> which collects the forward references under the hood. It will first collects the OSM data that should be written in a temporary file. When the writer is closed, it adds the forward references from a reference file. This means, the <code>ForwardReferenceWriter</code> needs two mandatory parameters to be instantiated: the name of the file to write to and the name of the file to copy the referenced data from:</p> In\u00a0[8]: Copied! <pre>writer = osmium.ForwardReferenceWriter('../data/out/centre.osm.pbf', '../data/liechtenstein.osm.pbf', overwrite=True)\n</pre> writer = osmium.ForwardReferenceWriter('../data/out/centre.osm.pbf', '../data/liechtenstein.osm.pbf', overwrite=True) <p>The writer will by default also add the necessary objects to make the file reference-complete. The writer can now replace the SimpleWriter in the code with the first attempt, resulting in the final solution shown in the Quick Solution.</p>"},{"location":"cookbooks/Filter-Data-By-Geometry/#filtering-by-geometry","title":"Filtering by Geometry\u00b6","text":"<p>How to create geographic extracts from an OSM file.</p>"},{"location":"cookbooks/Filter-Data-By-Geometry/#task","title":"Task\u00b6","text":"<p>Given the country extract of Liechtenstein, extract all data that is within 2km of the coordinates 47.13,9.52. All objects inside the geographic area should be complete, meaning that complete geometries can be created for them.</p>"},{"location":"cookbooks/Filter-Data-By-Geometry/#quick-solution","title":"Quick solution\u00b6","text":""},{"location":"cookbooks/Filter-Data-By-Geometry/#background","title":"Background\u00b6","text":"<p>OSM data is not a simple selection of geometries. In an OSM data file only the OSM nodes have a location. All other OSM object are made up of OSM nodes or other OSM objects. To find out where an OSM way or relation is located on the planet, it is necessary to go back to the nodes it references.</p> <p>For the task at hand this means that any filtering by geometry needs to start with the OSM nodes. Lets start with a simple script that writes out all the nodes within the circle defined in the task:</p>"},{"location":"cookbooks/Filtering-Data-By-Tags/","title":"Filtering an OSM File By Tags","text":"In\u00a0[1]: Copied! <pre>import osmium\n</pre> import osmium In\u00a0[2]: Copied! <pre>fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf').with_filter(osmium.filter.KeyFilter('amenity'))\n\nwith osmium.BackReferenceWriter(\"../data/out/schools_full.osm.pbf\", ref_src='../data/liechtenstein.osm.pbf', overwrite=True) as writer:\n    for obj in fp:\n         if obj.tags['amenity'] == 'school':\n             writer.add(obj)\n</pre> fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf').with_filter(osmium.filter.KeyFilter('amenity'))  with osmium.BackReferenceWriter(\"../data/out/schools_full.osm.pbf\", ref_src='../data/liechtenstein.osm.pbf', overwrite=True) as writer:     for obj in fp:          if obj.tags['amenity'] == 'school':              writer.add(obj) <p>When filtering objects from a file, it is important, to include all objects that are referenced by the filtered objects. The <code>BackReferenceWriter</code> collects the references and writes out a complete file.</p> In\u00a0[3]: Copied! <pre>fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf').with_filter(osmium.filter.KeyFilter('amenity'))\n</pre> fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf').with_filter(osmium.filter.KeyFilter('amenity')) <p>The additional filtering for the <code>school</code> value can then be done in the processing loop.</p> <p>Lets first check how many school objects are there:</p> In\u00a0[4]: Copied! <pre>from collections import Counter\n\ncnt = Counter()\n\nfor obj in fp:\n    if obj.tags['amenity'] == 'school':\n        cnt.update([obj.type_str()])\n\nf\"Nodes: {cnt['n']}   Ways: {cnt['w']}  Relations: {cnt['r']}\"\n</pre> from collections import Counter  cnt = Counter()  for obj in fp:     if obj.tags['amenity'] == 'school':         cnt.update([obj.type_str()])  f\"Nodes: {cnt['n']}   Ways: {cnt['w']}  Relations: {cnt['r']}\" Out[4]: <pre>'Nodes: 3   Ways: 19  Relations: 1'</pre> <p>The counter distinguishes by OSM object types. As we can see, schools exist as nodes (point geometries), ways (polygon geometries) and relations (multipolygon geometries). All of them need to appear in the output file.</p> <p>The simple solution seems to be to write them all out into a file:</p> In\u00a0[5]: Copied! <pre>with osmium.SimpleWriter('../data/out/schools.opl', overwrite=True) as writer:\n    for obj in fp:\n        if obj.tags['amenity'] == 'school':\n            writer.add(obj)\n</pre> with osmium.SimpleWriter('../data/out/schools.opl', overwrite=True) as writer:     for obj in fp:         if obj.tags['amenity'] == 'school':             writer.add(obj) <p>However, if you try to use the resulting file in another program, you may find that it complains that the data is incomplete. The schools that are saved as ways in the file reference nodes which are now missing. The school relation references ways which are missing. And these again reference nodes, which need to appear in the output file as well. The file needs to be made referentially complete.</p> In\u00a0[6]: Copied! <pre>references = {'n': set(), 'w': set(), 'r': set()} # save references by their object type\n\nfor obj in fp:\n    if obj.tags['amenity'] == 'school':\n        if obj.is_way():\n            references['n'].update(n.ref for n in obj.nodes)\n        elif obj.is_relation():\n            for member in obj.members:\n                references[member.type].add(member.ref)\n\nf\"Nodes: {len(references['n'])}   Ways: {len(references['w'])}  Relations: {len(references['r'])}\"\n</pre> references = {'n': set(), 'w': set(), 'r': set()} # save references by their object type  for obj in fp:     if obj.tags['amenity'] == 'school':         if obj.is_way():             references['n'].update(n.ref for n in obj.nodes)         elif obj.is_relation():             for member in obj.members:                 references[member.type].add(member.ref)  f\"Nodes: {len(references['n'])}   Ways: {len(references['w'])}  Relations: {len(references['r'])}\" Out[6]: <pre>'Nodes: 325   Ways: 3  Relations: 0'</pre> <p>This gives us a set of all the direct references: the nodes of the school ways and and the ways in the school relations. We are still missing the indirect references: the nodes from the ways of the school relations. It is not possible to collect those while scanning the file for the first time. By the time the relations are scanned and we know which additional ways are of interest, the ways have already been read. We could cache all the node locations when scanning the ways in the file for the first time but that can become quite a lot of data to remember. It is faster to simply scan the file again once we know which ways are of interest:</p> In\u00a0[7]: Copied! <pre>for obj in osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.WAY):\n    if obj.id in references['w']:\n        references['n'].update(n.ref for n in obj.nodes)\n\nf\"Nodes: {len(references['n'])}   Ways: {len(references['w'])}  Relations: {len(references['r'])}\"\n</pre> for obj in osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.WAY):     if obj.id in references['w']:         references['n'].update(n.ref for n in obj.nodes)  f\"Nodes: {len(references['n'])}   Ways: {len(references['w'])}  Relations: {len(references['r'])}\" Out[7]: <pre>'Nodes: 395   Ways: 3  Relations: 0'</pre> <p>This time it is not possible to use a key filter because the ways that are part of the relations are not necessarily tagged with <code>amenity=school</code>. They might not have any tags at all. However, we can use a different trick and tell the file processor to only scan the ways in the file. This is the second parameter in the <code>FileProcessor()</code> constructor.</p> <p>After this second scan of the file, we know the IDs of all the objects that need to go into the output file. The data we are interested in doesn't have nested relations. When relations contain other relations, then another scan of the file is required to collect the triple indirection. This part shall be left as an exercise to the reader for now.</p> <p>Once all the necessary ids are collected, the objects needs to be extracted from the original file. This can be done with the IdFilter. It gets a list of all object IDs it is supposed to let pass. Given that we need nodes and ways from the original file, two filters are necessary:</p> In\u00a0[8]: Copied! <pre>ref_fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.NODE | osmium.osm.WAY)\\\n               .with_filter(osmium.filter.IdFilter(references['n']).enable_for(osmium.osm.NODE))\\\n               .with_filter(osmium.filter.IdFilter(references['w']).enable_for(osmium.osm.WAY))\n</pre> ref_fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.NODE | osmium.osm.WAY)\\                .with_filter(osmium.filter.IdFilter(references['n']).enable_for(osmium.osm.NODE))\\                .with_filter(osmium.filter.IdFilter(references['w']).enable_for(osmium.osm.WAY))                <p>The data from this FileProcessor needs to be merged with the filtered data originally written out. We cannot just concatenate the two files because the order of elements matters. Most applications that process OSM data expect the elements in a well defined order: first nodes, then ways, then relations, all sorted by ID. When the input files are ordered correctly already, then the <code>zip_processors()</code> function can be used to iterate over multiple FileProcessors in parallel and write out the data:</p> In\u00a0[9]: Copied! <pre>filtered_fp = osmium.FileProcessor('../data/out/schools.opl')\n\nwith osmium.SimpleWriter(f'../data/out/schools_full.osm.pbf', overwrite=True) as writer:\n    for filtered_obj, ref_obj in osmium.zip_processors(filtered_fp, ref_fp):\n        if filtered_obj:\n            writer.add(filtered_obj)\n        else:\n            writer.add(ref_obj.replace(tags={}))\n</pre> filtered_fp = osmium.FileProcessor('../data/out/schools.opl')  with osmium.SimpleWriter(f'../data/out/schools_full.osm.pbf', overwrite=True) as writer:     for filtered_obj, ref_obj in osmium.zip_processors(filtered_fp, ref_fp):         if filtered_obj:             writer.add(filtered_obj)         else:             writer.add(ref_obj.replace(tags={})) <p>This writes the data from the filtered file, if any exists and otherwise takes the data from the original file. Objects from the original files have their tags removed. This avoids to have unwanted first-class objects in your file. All additionally added objects now exist for the sole purpose of completing the ones you have filtered.</p> In\u00a0[11]: Copied! <pre>references = osmium.IdTracker()\n\nwith osmium.SimpleWriter(f'../data/out/schools.opl', overwrite=True) as writer:\n    for obj in fp:\n        if obj.tags['amenity'] == 'school':\n            writer.add(obj)\n            references.add_references(obj)\n\nreferences.complete_backward_references('../data/liechtenstein.osm.pbf', relation_depth=10)\n</pre> references = osmium.IdTracker()  with osmium.SimpleWriter(f'../data/out/schools.opl', overwrite=True) as writer:     for obj in fp:         if obj.tags['amenity'] == 'school':             writer.add(obj)             references.add_references(obj)  references.complete_backward_references('../data/liechtenstein.osm.pbf', relation_depth=10) <p>The function <code>complete_backward_references()</code> repeatedly reads from the file to collect all referenced objects. In contrast to the more simple solution above, it can also collect references in nested relations. The <code>relation_depth</code> parameter controls how far the nesting should be followed. In this case, we have set it to 10 which should be sufficient even for the most complex relations in OSM. It is a good idea to not set this parameter too high because every level of depth requires an additional scan of the relations in the reference file.</p> <p>With all the IDs collected, the final file can be written out as above. IdTracker can directly pose as a filter to a FileProcessor, so that the code can be slightly simplified:</p> In\u00a0[12]: Copied! <pre>fp1 = osmium.FileProcessor('../data/out/schools.opl')\nfp2 = osmium.FileProcessor('../data/liechtenstein.osm.pbf').with_filter(references.id_filter())\n\nwith osmium.SimpleWriter('../data/out/schools_full.opl', overwrite=True) as writer:\n    for o1, o2 in osmium.zip_processors(fp1, fp2):\n        if o1:\n            writer.add(o1)\n        else:\n            writer.add(o2.replace(tags={}))\n</pre> fp1 = osmium.FileProcessor('../data/out/schools.opl') fp2 = osmium.FileProcessor('../data/liechtenstein.osm.pbf').with_filter(references.id_filter())  with osmium.SimpleWriter('../data/out/schools_full.opl', overwrite=True) as writer:     for o1, o2 in osmium.zip_processors(fp1, fp2):         if o1:             writer.add(o1)         else:             writer.add(o2.replace(tags={}))"},{"location":"cookbooks/Filtering-Data-By-Tags/#filtering-an-osm-file-by-tags","title":"Filtering an OSM File By Tags\u00b6","text":"<p>How to create a thematic extract from an OSM file.</p>"},{"location":"cookbooks/Filtering-Data-By-Tags/#task","title":"Task\u00b6","text":"<p>Given the country extract of Liechtenstein, create a fully usable OSM file that only contains all the schools in the file.</p>"},{"location":"cookbooks/Filtering-Data-By-Tags/#quick-solution","title":"Quick Solution\u00b6","text":""},{"location":"cookbooks/Filtering-Data-By-Tags/#background","title":"Background\u00b6","text":"<p>Filtering school objects from a file is fairly easy. We need a file processor for the target file which returns all objects with an <code>amenity</code> key:</p>"},{"location":"cookbooks/Filtering-Data-By-Tags/#finding-backward-references-manually","title":"Finding backward references manually\u00b6","text":"<p>Lets try to collect the IDs of the missing nodes and relation manually first. This helps to understand how the process works. In a first pass, we can simply collect all the IDs we encounter when processing the schools:</p>"},{"location":"cookbooks/Filtering-Data-By-Tags/#finding-backward-references-with-the-idtracker","title":"Finding backward references with the IDTracker\u00b6","text":"<p>The <code>IDTracker</code> class will track backward references for you just like described in the last paragraph.</p>"},{"location":"cookbooks/Filtering-Data-By-Tags/#using-backreferencewriter-to-collect-references","title":"Using BackReferenceWriter to collect references\u00b6","text":"<p>The BackReferenceWriter encapsulates a SimpleWriter and IdTracker and writes out the referenced objects, when <code>close()</code> is called. This reduces the task of filtering schools to the simple solution shown in the beginning.</p>"},{"location":"cookbooks/Visualizing-Data-With-Geopandas/","title":"Visualising Data With GeoPandas","text":"In\u00a0[1]: Copied! <pre>import osmium\nimport geopandas\n</pre> import osmium import geopandas In\u00a0[2]: Copied! <pre>fp = osmium.FileProcessor('../data/buildings.opl')\\\n         .with_areas()\\\n         .with_filter(osmium.filter.GeoInterfaceFilter())\n\nfeatures = geopandas.GeoDataFrame.from_features(fp)\nlen(features)\n</pre> fp = osmium.FileProcessor('../data/buildings.opl')\\          .with_areas()\\          .with_filter(osmium.filter.GeoInterfaceFilter())  features = geopandas.GeoDataFrame.from_features(fp) len(features) Out[2]: <pre>11</pre> <p>This will load every single OSM object into the GeoDataFrame as long as it can be converted into a geometry, including all untagged nodes. This is usually not what you want. Therefore it is important to carefully filter the data before giving it to the GeoHandler. In our case we are only interested in streets. That means, it must be linear ways with a tag 'highway'. Lets add the appropriate filters:</p> In\u00a0[3]: Copied! <pre>fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\\n         .with_locations()\\\n         .with_filter(osmium.filter.EntityFilter(osmium.osm.WAY))\\\n         .with_filter(osmium.filter.KeyFilter('highway'))\\\n         .with_filter(osmium.filter.GeoInterfaceFilter())\n\nfeatures = geopandas.GeoDataFrame.from_features(fp)\n</pre> fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\          .with_locations()\\          .with_filter(osmium.filter.EntityFilter(osmium.osm.WAY))\\          .with_filter(osmium.filter.KeyFilter('highway'))\\          .with_filter(osmium.filter.GeoInterfaceFilter())  features = geopandas.GeoDataFrame.from_features(fp) <p>The first filter restricts the selection to ways, the second filter only lets through highway objects. Let's have a look at the result:</p> In\u00a0[4]: Copied! <pre>features.plot()\n</pre> features.plot() Out[4]: <pre>&lt;Axes: &gt;</pre> <p>This shows all the highway features of Liechtenstein, including footways and paths:</p> In\u00a0[5]: Copied! <pre>features\n</pre> features Out[5]: geometry highway name cycleway:both lane_markings oneway surface lanes maxspeed smoothness ... informal bench operator shelter traffic_calming vehicle:conditional agricultural old_name crossing bin 0 LINESTRING (9.54963 47.18788, 9.54968 47.18792... residential In den \u00c4usseren NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 1 LINESTRING (9.54173 47.18223, 9.54212 47.18255... tertiary Dorfstrasse no no no asphalt NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 2 LINESTRING (9.51716 47.17078, 9.51719 47.17074... tertiary Planknerstrasse NaN NaN no asphalt 2 50 good ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 3 LINESTRING (9.55048 47.18784, 9.55042 47.18778... residential Oberplanknerstrasse NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 4 LINESTRING (9.54627 47.18504, 9.54649 47.18508... residential Im H\u00e4ldele NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 7501 LINESTRING (9.54458 47.18668, 9.54461 47.18667) footway NaN NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 7502 LINESTRING (9.54374 47.18631, 9.54395 47.18649) service Unterm Rain NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 7503 LINESTRING (9.54434 47.18478, 9.54444 47.18474) steps NaN NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 7504 LINESTRING (9.54470 47.18497, 9.54471 47.18501) service NaN NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 7505 LINESTRING (9.54445 47.18494, 9.54452 47.18490) footway NaN NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN <p>7506 rows \u00d7 154 columns</p> <p>It also contains all possible tags, that an OSM object can have. We are only interested in a selected number of tags. The GeoHandler can be instructed to restrict the tags, it adds to the properties:</p> In\u00a0[6]: Copied! <pre>fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\\n         .with_locations()\\\n         .with_filter(osmium.filter.EntityFilter(osmium.osm.WAY))\\\n         .with_filter(osmium.filter.KeyFilter('highway'))\\\n         .with_filter(osmium.filter.GeoInterfaceFilter(tags=['highway', 'name', 'maxspeed']))\n\nfeatures = geopandas.GeoDataFrame.from_features(fp)\n</pre> fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\          .with_locations()\\          .with_filter(osmium.filter.EntityFilter(osmium.osm.WAY))\\          .with_filter(osmium.filter.KeyFilter('highway'))\\          .with_filter(osmium.filter.GeoInterfaceFilter(tags=['highway', 'name', 'maxspeed']))  features = geopandas.GeoDataFrame.from_features(fp) <p>This leaves us with a more concise data frame:</p> In\u00a0[7]: Copied! <pre>features\n</pre> features Out[7]: geometry highway name maxspeed 0 LINESTRING (9.54963 47.18788, 9.54968 47.18792... residential In den \u00c4usseren NaN 1 LINESTRING (9.54173 47.18223, 9.54212 47.18255... tertiary Dorfstrasse NaN 2 LINESTRING (9.51716 47.17078, 9.51719 47.17074... tertiary Planknerstrasse 50 3 LINESTRING (9.55048 47.18784, 9.55042 47.18778... residential Oberplanknerstrasse NaN 4 LINESTRING (9.54627 47.18504, 9.54649 47.18508... residential Im H\u00e4ldele NaN ... ... ... ... ... 7501 LINESTRING (9.54458 47.18668, 9.54461 47.18667) footway NaN NaN 7502 LINESTRING (9.54374 47.18631, 9.54395 47.18649) service Unterm Rain NaN 7503 LINESTRING (9.54434 47.18478, 9.54444 47.18474) steps NaN NaN 7504 LINESTRING (9.54470 47.18497, 9.54471 47.18501) service NaN NaN 7505 LINESTRING (9.54445 47.18494, 9.54452 47.18490) footway NaN NaN <p>7506 rows \u00d7 4 columns</p> <p>All that is left, to plot the ways according to their maxspeed:</p> In\u00a0[8]: Copied! <pre>features.plot(\"maxspeed\")\n</pre> features.plot(\"maxspeed\") Out[8]: <pre>&lt;Axes: &gt;</pre>"},{"location":"cookbooks/Visualizing-Data-With-Geopandas/#visualising-data-with-geopandas","title":"Visualising Data With GeoPandas\u00b6","text":"<p>How to convert OSM data into a GeoPandas frame for further processing.</p>"},{"location":"cookbooks/Visualizing-Data-With-Geopandas/#task","title":"Task\u00b6","text":"<p>Show the street network of the input data on a map with different colors for the different maximum speeds.</p>"},{"location":"cookbooks/Visualizing-Data-With-Geopandas/#solution","title":"Solution\u00b6","text":"<p>GeoPanadas is a useful tool to help you process and visualise geodata in a Jupyter notebook. It can read data from many sources. Among others, it can read geo features from a Python iterable where each element implements the <code>__geo_interface__</code>. An 'osmium.FileProcessor' happens to behave like a Python iterable. To make it compatible with GeoPandas, the output objects need to be extended with a <code>__geo_interface__</code>. This can be done with the GeoInterfaceFilter. This filter adds a geometry to the object. Therefore, geometry processing needs to be enabled accordingly:</p>"},{"location":"reference/Area/","title":"Area building","text":""},{"location":"reference/Area/#osmium.area.AreaManager","title":"<code>osmium.area.AreaManager</code>","text":"<p>               Bases: <code>osmium.BaseHandler</code></p> <p>Handler class that manages building area objects from ways and relations.</p> <p>Building area objects always requires two passes through the file: in the first pass, the area manager collects the relation candidates for areas and IDs of all ways that are needed to build their areas. During the second pass of the file the areas are assembled: areas from ways are created immediately when the handler encounters a closed way. Areas for relations are built as soon as all the ways that the relation needs are available.</p> <p>You usually should not be using the AreaManager direcly. The interface of the handler is considered an internal implementation detail and may change in future versions of pyosmium. Area assembly can be enabled through the SimpleHandler and the FileProcessor.</p>"},{"location":"reference/Area/#osmium.area.AreaManager.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Set up a new area manager.</p>"},{"location":"reference/Area/#osmium.area.AreaManager.first_pass_handler","title":"<code>first_pass_handler() -&gt; AreaManager</code>","text":"<p>Return a handler object to be used for the first pass through a file. It collects information about area relations and their way members.</p>"},{"location":"reference/Area/#osmium.area.AreaManager.second_pass_handler","title":"<code>second_pass_handler(*handlers: HandlerLike) -&gt; AreaManagerSecondPassHandler</code>","text":"<p>Return a handler used for the second pass of the file, where areas are assembled. Pass the chain of filters and handlers that should be applied the areas.</p>"},{"location":"reference/Area/#osmium.area.AreaManager.second_pass_to_buffer","title":"<code>second_pass_to_buffer(callback: BufferIterator) -&gt; AreaManagerBufferHandler</code>","text":"<p>Return a handler for the second pass of the file, which stores assembled areas in the given buffer.</p>"},{"location":"reference/Data-Writers/","title":"Data writers","text":""},{"location":"reference/Data-Writers/#osmium.SimpleWriter","title":"<code>osmium.SimpleWriter</code>","text":"<p>               Bases: <code>osmium._osmium.BaseHandler</code></p> <p>Basic writer for OSM data. The SimpleWriter can write out object that are explicitly passed or function as a handler and write out all objects it receives. It is also possible to mix these two modes of operations.</p> <p>The writer writes out the objects in the order it receives them. It is the responsibility of the caller to ensure to follow the ordering conventions for OSM files.</p> <p>The SimpleWriter should normally used as a context manager. If you don't use it in a <code>with</code> context, don't forget to call <code>close()</code>, when writing is finished.</p>"},{"location":"reference/Data-Writers/#osmium.SimpleWriter.__init__","title":"<code>__init__(file: Union[str, os.PathLike[str], File], bufsz: int = ..., header: Optional[Header] = ..., overwrite: bool = ..., filetype: str = ...) -&gt; None</code>","text":"<p>Initiate a new writer for the given file. The writer will refuse to overwrite an already existing file unless overwrite is explicitly set to <code>True</code>.</p> <p>The file type is usually determined from the file extension. If you want to explicitly set the filetype (for example, when writing to standard output '-'), then use a File object. Using the filetype parameter to set the file type is deprecated and only works when the file is a string.</p> <p>The header parameter can be used to set a custom header in the output file. What kind of information can be written into the file header depends on the file type.</p> <p>The optional parameter bufsz sets the size of the buffers used for collecting the data before they are written out. The default size is 4MB. Larger buffers are normally better but you should be aware that there are normally multiple buffers in use during the write process.</p>"},{"location":"reference/Data-Writers/#osmium.SimpleWriter.add","title":"<code>add(obj: object) -&gt; None</code>","text":"<p>Add a new object to the file. The function will try to determine the kind of object automatically.</p>"},{"location":"reference/Data-Writers/#osmium.SimpleWriter.add_node","title":"<code>add_node(node: object) -&gt; None</code>","text":"<p>Add a new node to the file. The node may be a Node object or its mutable variant or any other Python object that implements the same attributes.</p>"},{"location":"reference/Data-Writers/#osmium.SimpleWriter.add_relation","title":"<code>add_relation(relation: object) -&gt; None</code>","text":"<p>Add a new relation to the file. The relation may be a Relation object or its mutable variant or any other Python object that implements the same attributes.</p>"},{"location":"reference/Data-Writers/#osmium.SimpleWriter.add_way","title":"<code>add_way(way: object) -&gt; None</code>","text":"<p>Add a new way to the file. The way may be a Way object or its mutable variant or any other Python object that implements the same attributes.</p>"},{"location":"reference/Data-Writers/#osmium.SimpleWriter.close","title":"<code>close() -&gt; None</code>","text":"<p>Flush the remaining buffers and close the writer. While it is not strictly necessary to call this function explicitly, it is still strongly recommended to close the writer as soon as possible, so that the buffer memory can be freed.</p>"},{"location":"reference/Data-Writers/#osmium.WriteHandler","title":"<code>osmium.WriteHandler</code>","text":"<p>               Bases: <code>osmium._osmium.SimpleWriter</code></p> <p>(Deprecated) Handler function that writes all data directly to a file.</p> <p>This is now simply an alias for SimpleWriter. Please refer to its documentation.</p>"},{"location":"reference/Data-Writers/#osmium.BackReferenceWriter","title":"<code>osmium.BackReferenceWriter</code>","text":"<p>Writer that adds referenced objects, so that all written objects are reference-complete.</p> <p>The collected data is first written into a temporary file and the necessary references are tracked internally. When the writer is closed, it writes the final file, mixing together the referenced objects from the original file and the written data.</p> <p>The writer should usually be used as a context manager.</p>"},{"location":"reference/Data-Writers/#osmium.BackReferenceWriter.__init__","title":"<code>__init__(outfile: Union[str, os.PathLike[str], File], ref_src: Union[str, os.PathLike[str], File, FileBuffer], overwrite: bool = False, remove_tags: bool = True, relation_depth: int = 0)</code>","text":"<p>Create a new writer.</p> <p><code>outfile</code> is the name of the output file to write. The file must not yet exist unless <code>overwrite</code> is set to True.</p> <p><code>ref_src</code> is the OSM input file, where to take the reference objects from. This is usually the same file the data to be written is taken from.</p> <p>The writer will by default remove all tags from referenced objects, so that they do not appear as stray objects in the file. Set <code>remove_tags</code> to False to keep the tags.</p> <p>The writer will not complete nested relations by default. If you need nested relations, set <code>relation_depth</code> to the minimum depth to which relations shall be completed.</p>"},{"location":"reference/Data-Writers/#osmium.BackReferenceWriter.add","title":"<code>add(obj: Any) -&gt; None</code>","text":"<p>Write an arbitrary OSM object. This can be either an osmium object or a Python object that has the appropriate attributes.</p>"},{"location":"reference/Data-Writers/#osmium.BackReferenceWriter.add_node","title":"<code>add_node(n: Any) -&gt; None</code>","text":"<p>Write out an OSM node.</p>"},{"location":"reference/Data-Writers/#osmium.BackReferenceWriter.add_relation","title":"<code>add_relation(r: Any) -&gt; None</code>","text":"<p>Write out an OSM relation.</p>"},{"location":"reference/Data-Writers/#osmium.BackReferenceWriter.add_way","title":"<code>add_way(w: Any) -&gt; None</code>","text":"<p>Write out an OSM way.</p>"},{"location":"reference/Data-Writers/#osmium.BackReferenceWriter.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the writer and write out the final file.</p> <p>The function will be automatically called when the writer is used as a context manager.</p>"},{"location":"reference/Data-Writers/#osmium.ForwardReferenceWriter","title":"<code>osmium.ForwardReferenceWriter</code>","text":"<p>Writer that adds forward-referenced objects optionally also making the final file reference complete. An object is a forward reference when it directly or indirectly needs one of the objects originally written out.</p> <p>The collected data is first written into a temporary file, When the writer is closed, the references are collected from the reference file and written out together with the collected data into the final file.</p> <p>The writer should usually be used as a context manager.</p>"},{"location":"reference/Data-Writers/#osmium.ForwardReferenceWriter.__init__","title":"<code>__init__(outfile: Union[str, os.PathLike[str], File], ref_src: Union[str, os.PathLike[str], File, FileBuffer], overwrite: bool = False, back_references: bool = True, remove_tags: bool = True, forward_relation_depth: int = 0, backward_relation_depth: int = 1) -&gt; None</code>","text":"<p>Create a new writer.</p> <p><code>outfile</code> is the name of the output file to write. The file must not yet exist unless <code>overwrite</code> is set to True.</p> <p><code>ref_src</code> is the OSM input file, where to take the reference objects from. This is usually the same file the data to be written is taken from.</p> <p>The writer will collect back-references by default to make the file reference-complete. Set <code>back_references=False</code> to disable this behaviour.</p> <p>The writer will not complete nested relations by default. If you need nested relations, set <code>relation_depth</code> to the minimum depth to which relations shall be completed.</p>"},{"location":"reference/Data-Writers/#osmium.ForwardReferenceWriter.add","title":"<code>add(obj: Any) -&gt; None</code>","text":"<p>Write an arbitrary OSM object. This can be either an osmium object or a Python object that has the appropriate attributes.</p>"},{"location":"reference/Data-Writers/#osmium.ForwardReferenceWriter.add_node","title":"<code>add_node(n: Any) -&gt; None</code>","text":"<p>Write out an OSM node.</p>"},{"location":"reference/Data-Writers/#osmium.ForwardReferenceWriter.add_relation","title":"<code>add_relation(r: Any) -&gt; None</code>","text":"<p>Write out an OSM relation.</p>"},{"location":"reference/Data-Writers/#osmium.ForwardReferenceWriter.add_way","title":"<code>add_way(w: Any) -&gt; None</code>","text":"<p>Write out an OSM way.</p>"},{"location":"reference/Data-Writers/#osmium.ForwardReferenceWriter.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the writer and write out the final file.</p> <p>The function will be automatically called when the writer is used as a context manager.</p>"},{"location":"reference/Dataclasses/","title":"OSM data views","text":"<p>These classes expose the data from an OSM file to the Python scripts. Objects of these classes are always views unless stated otherwise. This means that they are only valid as long as the view to an object is valid.</p>"},{"location":"reference/Dataclasses/#osm-types","title":"OSM types","text":""},{"location":"reference/Dataclasses/#osmium.osm.osm_entity_bits","title":"<code>osmium.osm.osm_entity_bits</code>","text":""},{"location":"reference/Dataclasses/#osm-primary-objects","title":"OSM primary objects","text":""},{"location":"reference/Dataclasses/#osmium.osm.OSMObject","title":"<code>osmium.osm.OSMObject</code>","text":"<p>This is the base class for all OSM entity classes below and contains all common attributes.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.changeset","title":"<code>changeset: int</code>  <code>property</code>","text":"<p>(read-only) Id of changeset where this version of the object was created.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.deleted","title":"<code>deleted: bool</code>  <code>property</code>","text":"<p>(read-only) True if the object is no longer visible.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>(read-only) OSM id of the object.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.tags","title":"<code>tags: TagList</code>  <code>property</code>","text":"<p>(read-only) List of tags describing the object. See <code>osmium.osm.TagList</code>.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.timestamp","title":"<code>timestamp: dt.datetime</code>  <code>property</code>","text":"<p>(read-only) Date when this version has been created, returned as a <code>datetime.datetime</code>.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.uid","title":"<code>uid: int</code>  <code>property</code>","text":"<p>(read-only) Id of the user that created this version of the object. Only this ID uniquely identifies users.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.user","title":"<code>user: str</code>  <code>property</code>","text":"<p>(read-only) Name of the user that created this version. Be aware that user names can change, so that the same user ID may appear with different names and vice versa.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.version","title":"<code>version: int</code>  <code>property</code>","text":"<p>(read-only) Version number of the object.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.visible","title":"<code>visible: bool</code>  <code>property</code>","text":"<p>(read-only) True if the object is visible.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.is_area","title":"<code>is_area() -&gt; bool</code>","text":"<p>Return true if the object is a Way object.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.is_node","title":"<code>is_node() -&gt; bool</code>","text":"<p>Return true if the object is a Node object.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.is_relation","title":"<code>is_relation() -&gt; bool</code>","text":"<p>Return true if the object is a Relation object.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.is_way","title":"<code>is_way() -&gt; bool</code>","text":"<p>Return true if the object is a Way object.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.positive_id","title":"<code>positive_id() -&gt; int</code>","text":"<p>Get the absolute value of the id of this object.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.type_str","title":"<code>type_str() -&gt; str</code>","text":"<p>Return a single character identifying the type of the object. The character is the same as used in OPL.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OSMObject.user_is_anonymous","title":"<code>user_is_anonymous() -&gt; bool</code>","text":"<p>Check if the user is anonymous. If true, the uid does not uniquely identify a single user but only the group of all anonymous users in general.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Node","title":"<code>osmium.osm.Node</code>","text":"<p>               Bases: <code>osmium.osm.types.OSMObject['cosm.COSMNode']</code></p> <p>Represents a single OSM node. It inherits all properties from OSMObjects and adds a single extra attribute: the location.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Node.lat","title":"<code>lat: float</code>  <code>property</code>","text":"<p>Return latitude of the node.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Node.location","title":"<code>location: osmium.osm.Location</code>  <code>property</code>","text":"<p>The geographic coordinates of the node. See <code>osmium.osm.Location</code>.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Node.lon","title":"<code>lon: float</code>  <code>property</code>","text":"<p>Return longitude of the node.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Node.replace","title":"<code>replace(**kwargs: Any) -&gt; osmium.osm.mutable.Node</code>","text":"<p>Create a mutable node replacing the properties given in the named parameters. The properties may be any of the properties of OSMObject or Node.</p> <p>Note that this function only creates a shallow copy per default. It is still bound to the scope of the original object. To create a full copy use: <code>node.replace(tags=dict(node.tags))</code></p>"},{"location":"reference/Dataclasses/#osmium.osm.Way","title":"<code>osmium.osm.Way</code>","text":"<p>               Bases: <code>osmium.osm.types.OSMObject['cosm.COSMWay']</code></p> <p>Represents an OSM way. It inherits the attributes from OSMObject and adds an ordered list of nodes that describes the way.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Way.nodes","title":"<code>nodes: WayNodeList</code>  <code>property</code>","text":"<p>(read-only) Ordered list of nodes. See <code>osmium.osm.WayNodeList</code>.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Way.ends_have_same_id","title":"<code>ends_have_same_id() -&gt; bool</code>","text":"<p>True if the start and end node are exactly the same.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Way.ends_have_same_location","title":"<code>ends_have_same_location() -&gt; bool</code>","text":"<p>True if the start and end node of the way are at the same location. Expects that the coordinates of the way nodes have been loaded (see SimpleHandler apply functions and <code>FileProcessor.with_locations()</code>) If the locations are not present then the function returns always true.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Way.is_closed","title":"<code>is_closed() -&gt; bool</code>","text":"<p>True if the start and end node are the same (synonym for <code>ends_have_same_id</code>).</p>"},{"location":"reference/Dataclasses/#osmium.osm.Way.replace","title":"<code>replace(**kwargs: Any) -&gt; osmium.osm.mutable.Way</code>","text":"<p>Create a mutable way replacing the properties given in the named parameters. The properties may be any of the properties of OSMObject or Way.</p> <p>Note that this function only creates a shallow copy per default. It is still bound to the scope of the original object. To create a full copy use: <code>way.replace(tags=dict(way.tags), nodes=list(way.nodes))</code></p>"},{"location":"reference/Dataclasses/#osmium.osm.Relation","title":"<code>osmium.osm.Relation</code>","text":"<p>               Bases: <code>osmium.osm.types.OSMObject['cosm.COSMRelation']</code></p> <p>Represents a OSM relation. It inherits the attributes from OSMObject and adds an ordered list of members.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Relation.members","title":"<code>members: RelationMemberList</code>  <code>property</code>","text":"<p>(read-only) Ordered list of relation members. See <code>osmium.osm.RelationMemberList</code>.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Relation.replace","title":"<code>replace(**kwargs: Any) -&gt; osmium.osm.mutable.Relation</code>","text":"<p>Create a mutable relation replacing the properties given in the named parameters. The properties may be any of the properties of OSMObject or Relation.</p> <p>Note that this function only creates a shallow copy per default. It is still bound to the scope of the original object. To create a full copy use: <code>rel.replace(tags=dict(rel.tags), members=list(rel.members))</code></p>"},{"location":"reference/Dataclasses/#osmium.osm.Area","title":"<code>osmium.osm.Area</code>","text":"<p>               Bases: <code>osmium.osm.types.OSMObject['cosm.COSMArea']</code></p> <p>Areas are a special kind of meta-object representing a polygon. They can either be derived from closed ways or from relations that represent multipolygons. They also inherit the attributes of OSMObjects and in addition contain polygon geometries. Areas have their own unique id space. This is computed as the OSM id times 2 and for relations 1 is added.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Area.from_way","title":"<code>from_way() -&gt; bool</code>","text":"<p>Return true if the area was created from a way, false if it was created from a relation of multipolygon type.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Area.inner_rings","title":"<code>inner_rings(oring: OuterRing) -&gt; InnerRingIterator</code>","text":"<p>Return an iterator over all inner rings of the multipolygon.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Area.is_multipolygon","title":"<code>is_multipolygon() -&gt; bool</code>","text":"<p>Return true if this area is a true multipolygon, i.e. it consists of multiple outer rings.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Area.num_rings","title":"<code>num_rings() -&gt; Tuple[int, int]</code>","text":"<p>Return a tuple with the number of outer rings and inner rings.</p> <p>This function goes through all rings to count them.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Area.orig_id","title":"<code>orig_id() -&gt; int</code>","text":"<p>Compute the original OSM id of this object. Note that this is not necessarily unique because the object might be a way or relation which have an overlapping id space.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Area.outer_rings","title":"<code>outer_rings() -&gt; OuterRingIterator</code>","text":"<p>Return an iterator over all outer rings of the multipolygon.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset","title":"<code>osmium.osm.Changeset</code>","text":"<p>A changeset description.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.bounds","title":"<code>bounds: osmium.osm.Box</code>  <code>property</code>","text":"<p>(read-only) The bounding box of the area that was edited.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.closed_at","title":"<code>closed_at: dt.datetime</code>  <code>property</code>","text":"<p>(read-only) Timestamp when the changeset was finalized. May be <code>None</code> when the changeset is still open.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.created_at","title":"<code>created_at: dt.datetime</code>  <code>property</code>","text":"<p>(read-only) Timestamp when the changeset was first opened.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>(read-only) Unique ID of the changeset.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.num_changes","title":"<code>num_changes: int</code>  <code>property</code>","text":"<p>(read-only) The total number of objects changed in this Changeset.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.open","title":"<code>open: bool</code>  <code>property</code>","text":"<p>(read-only) True when the changeset is still open.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.tags","title":"<code>tags: TagList</code>  <code>property</code>","text":"<p>(read-only) List of tags describing the object. See <code>osmium.osm.TagList</code>.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.uid","title":"<code>uid: int</code>  <code>property</code>","text":"<p>(read-only) User ID of the changeset creator.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.user","title":"<code>user: str</code>  <code>property</code>","text":"<p>(read-only) Name of the user that created the changeset. Be aware that user names can change, so that the same user ID may appear with different names and vice versa.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Changeset.user_is_anonymous","title":"<code>user_is_anonymous() -&gt; bool</code>","text":"<p>Check if the user anonymous. If true, the uid does not uniquely identify a single user but only the group of all anonymous users in general.</p>"},{"location":"reference/Dataclasses/#tag-lists","title":"Tag lists","text":""},{"location":"reference/Dataclasses/#osmium.osm.Tag","title":"<code>osmium.osm.Tag</code>","text":"<p>               Bases: <code>typing.NamedTuple</code></p> <p>A single OSM tag.</p>"},{"location":"reference/Dataclasses/#osmium.osm.Tag.k","title":"<code>k: str</code>  <code>instance-attribute</code>","text":"<p>Tag key</p>"},{"location":"reference/Dataclasses/#osmium.osm.Tag.v","title":"<code>v: str</code>  <code>instance-attribute</code>","text":"<p>Tag value</p>"},{"location":"reference/Dataclasses/#osmium.osm.TagList","title":"<code>osmium.osm.TagList</code>","text":"<p>               Bases: <code>typing.Iterable[osmium.osm.types.Tag]</code></p> <p>A fixed list of tags. The list is exported as an unmutable, dictionary-like object where the keys are tag strings and the items are Tags.</p>"},{"location":"reference/Dataclasses/#osmium.osm.TagList.get","title":"<code>get(key: str, default: Optional[str] = None) -&gt; Optional[str]</code>","text":"<p>Return the value for the given key. or 'value' if the key does not exist in the list.</p>"},{"location":"reference/Dataclasses/#node-lists","title":"Node lists","text":""},{"location":"reference/Dataclasses/#osmium.osm.NodeRef","title":"<code>osmium.osm.NodeRef</code>","text":"<p>A reference to a OSM node that also caches the nodes location.</p>"},{"location":"reference/Dataclasses/#osmium.osm.NodeRef.lat","title":"<code>lat: float</code>  <code>property</code>","text":"<p>(read-only) Latitude (y coordinate) as floating point number.</p>"},{"location":"reference/Dataclasses/#osmium.osm.NodeRef.lon","title":"<code>lon: float</code>  <code>property</code>","text":"<p>(read-only) Longitude (x coordinate) as floating point number.</p>"},{"location":"reference/Dataclasses/#osmium.osm.NodeRef.x","title":"<code>x: int</code>  <code>property</code>","text":"<p>(read-only) X coordinate (longitude) as a fixed-point integer.</p>"},{"location":"reference/Dataclasses/#osmium.osm.NodeRef.y","title":"<code>y: int</code>  <code>property</code>","text":"<p>(read-only) Y coordinate (latitude) as a fixed-point integer.</p>"},{"location":"reference/Dataclasses/#osmium.osm.NodeRefList","title":"<code>osmium.osm.NodeRefList</code>","text":"<p>A list of node references, implemented as an immutable sequence of osmium.osm.NodeRef. This class is normally not used directly, use one of its subclasses instead.</p>"},{"location":"reference/Dataclasses/#osmium.osm.NodeRefList.ends_have_same_id","title":"<code>ends_have_same_id() -&gt; bool</code>","text":"<p>True if the start and end node are exactly the same.</p>"},{"location":"reference/Dataclasses/#osmium.osm.NodeRefList.ends_have_same_location","title":"<code>ends_have_same_location() -&gt; bool</code>","text":"<p>True if the start and end node of the way are at the same location. \" Expects that the coordinates of the way nodes have been loaded (SimpleHandler apply functions and <code>FileProcessor.with_locations()</code>). If the locations are not present then the function returns always true.</p>"},{"location":"reference/Dataclasses/#osmium.osm.NodeRefList.is_closed","title":"<code>is_closed() -&gt; bool</code>","text":"<p>True if the start and end node are the same (synonym for <code>ends_have_same_id</code>).</p>"},{"location":"reference/Dataclasses/#osmium.osm.WayNodeList","title":"<code>osmium.osm.WayNodeList</code>","text":"<p>               Bases: <code>osmium.osm.types.NodeRefList</code></p> <p>List of nodes in a way. For its members see <code>osmium.osm.NodeRefList</code>.</p>"},{"location":"reference/Dataclasses/#osmium.osm.InnerRing","title":"<code>osmium.osm.InnerRing</code>","text":"<p>               Bases: <code>osmium.osm.types.NodeRefList</code></p> <p>List of nodes in an inner ring. \" For its members see <code>osmium.osm.NodeRefList</code>.</p>"},{"location":"reference/Dataclasses/#osmium.osm.OuterRing","title":"<code>osmium.osm.OuterRing</code>","text":"<p>               Bases: <code>osmium.osm.types.NodeRefList</code></p> <p>List of nodes in an outer ring. For its members see <code>osmium.osm.NodeRefList</code>.</p>"},{"location":"reference/Dataclasses/#relation-members","title":"Relation members","text":""},{"location":"reference/Dataclasses/#osmium.osm.RelationMember","title":"<code>osmium.osm.RelationMember</code>","text":"<p>Single member of a relation.</p>"},{"location":"reference/Dataclasses/#osmium.osm.RelationMember.ref","title":"<code>ref: int = ref</code>  <code>instance-attribute</code>","text":"<p>OSM ID of the object. Only unique within the type.</p>"},{"location":"reference/Dataclasses/#osmium.osm.RelationMember.role","title":"<code>role: str = role</code>  <code>instance-attribute</code>","text":"<p>The role of the member within the relation, a free-text string. If no role is set then the string is empty.</p>"},{"location":"reference/Dataclasses/#osmium.osm.RelationMember.type","title":"<code>type: str = mtype</code>  <code>instance-attribute</code>","text":"<p>Type of object referenced, a node, way or relation.</p>"},{"location":"reference/Dataclasses/#osmium.osm.RelationMemberList","title":"<code>osmium.osm.RelationMemberList</code>","text":"<p>An immutable  sequence of relation members <code>osmium.osm.RelationMember</code>.</p>"},{"location":"reference/Dataclasses/#geometry-types","title":"Geometry types","text":""},{"location":"reference/Dataclasses/#osmium.osm.Box","title":"<code>osmium.osm.Box</code>","text":""},{"location":"reference/Dataclasses/#osmium.osm.Location","title":"<code>osmium.osm.Location</code>","text":""},{"location":"reference/Exceptions/","title":"Exceptions","text":""},{"location":"reference/Exceptions/#osmium.InvalidLocationError","title":"<code>osmium.InvalidLocationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the location of a node is requested that has no valid location. To be valid, a location must be inside the -180 to 180 and -90 to 90 degree range.</p>"},{"location":"reference/File-Processing/","title":"Iterative Data Reading","text":""},{"location":"reference/File-Processing/#osmium.FileProcessor","title":"<code>osmium.FileProcessor</code>","text":"<p>A processor that reads an OSM file in a streaming fashion, optionally pre-filters the data, enhances it with geometry information, returning the data via an iterator.</p>"},{"location":"reference/File-Processing/#osmium.FileProcessor.header","title":"<code>header: osmium.io.Header</code>  <code>property</code>","text":"<p>(read-only) Header information for the file to be read.</p>"},{"location":"reference/File-Processing/#osmium.FileProcessor.node_location_storage","title":"<code>node_location_storage: Optional[LocationTable]</code>  <code>property</code>","text":"<p>Node location cache currently in use, if enabled. This can be used to manually look up locations of nodes. Be aware that the nodes must have been read before you can do a lookup via the location storage.</p>"},{"location":"reference/File-Processing/#osmium.FileProcessor.__init__","title":"<code>__init__(indata: Union[File, FileBuffer, str, os.PathLike[str]], entities: osmium.osm.osm_entity_bits = osmium.osm.ALL) -&gt; None</code>","text":"<p>Initialise a new file processor for the given input source indata. This may either be a filename, an instance of File or buffered data in form of a FileBuffer.</p> <p>The types of objects which will be read from the file can be restricted with the entities parameter. The data will be skipped directly at the source file and will never be passed to any filters including the location and area processors. You usually should not be restricting objects, when using those.</p>"},{"location":"reference/File-Processing/#osmium.FileProcessor.handler_for_filtered","title":"<code>handler_for_filtered(handler: osmium._osmium.HandlerLike) -&gt; FileProcessor</code>","text":"<p>Set a fallback handler for object that have been filtered out.</p> <p>Any object that does not pass the filter chain installed with <code>with_filter()</code> will be passed to this handler. This can be useful when the entire contents of a file should be passed to a writer and only some of the objects need to be processed specially in the iterator body.</p>"},{"location":"reference/File-Processing/#osmium.FileProcessor.with_areas","title":"<code>with_areas(*filters: osmium._osmium.HandlerLike) -&gt; FileProcessor</code>","text":"<p>Enable area processing. When enabled, then closed ways and relations of type multipolygon will also be returned as an Area type.</p> <p>Optionally one or more filters can be passed. These filters will be applied in the first pass, when relation candidates for areas are selected. Calling this function multiple times causes more filters to be added to the filter chain.</p> <p>Calling this function automatically enables location caching if it was not enabled yet using the default storage type. To use a different storage type, call <code>with_locations()</code> explicity with the approriate storage parameter before calling this function.</p>"},{"location":"reference/File-Processing/#osmium.FileProcessor.with_filter","title":"<code>with_filter(filt: osmium._osmium.HandlerLike) -&gt; FileProcessor</code>","text":"<p>Add a filter function to the processors filter chain. Filters are called for each prcoessed object in the order they have been installed. Only when the object passes all the filter functions will it be handed to the iterator.</p> <p>Note that any handler-like object can be installed as a filter. A non-filtering handler simply works like an all-pass filter.</p>"},{"location":"reference/File-Processing/#osmium.FileProcessor.with_locations","title":"<code>with_locations(storage: str = 'flex_mem') -&gt; FileProcessor</code>","text":"<p>Enable caching of node locations. The file processor will keep the coordinates of all nodes that are read from the file in memory and automatically enhance the node list of ways with the coordinates from the cache. This information can then be used to create geometries for ways. The node location cache can also be directly queried through the node_location_storage property.</p> <p>The storage parameter can be used to change the type of cache used to store the coordinates. The default 'flex_mem' is good for small to medium-sized files. For large files you may need to switch to a disk-storage based implementation because the cache can become quite large. See the section on location storage in the user manual for more information.</p>"},{"location":"reference/File-Processing/#osmium.OsmFileIterator","title":"<code>osmium.OsmFileIterator</code>","text":"<p>Low-level iterator interface for reading from an OSM source.</p>"},{"location":"reference/File-Processing/#osmium.OsmFileIterator.__init__","title":"<code>__init__(reader: Reader, *handlers: HandlerLike) -&gt; None</code>","text":"<p>Initialise a new iterator using the given reader as source. Each object is passed through the list of filters given by handlers. If all the filters are passed, the object is returned by <code>next()</code>.</p>"},{"location":"reference/File-Processing/#osmium.OsmFileIterator.set_filtered_handler","title":"<code>set_filtered_handler(handler: object) -&gt; None</code>","text":"<p>Set a fallback handler for objects that have been filtered out. The objects will be passed to the single handler.</p>"},{"location":"reference/File-Processing/#osmium.BufferIterator","title":"<code>osmium.BufferIterator</code>","text":"<p>(internal) Iterator interface for reading from a queue of buffers.</p> <p>This class is needed for pyosmium's internal implementation. There is currently no way to create buffers or add them to the iterator from Python.</p>"},{"location":"reference/File-Processing/#osmium.BufferIterator.__init__","title":"<code>__init__(*handlers: HandlerLike) -&gt; None</code>","text":"<p>Create a new iterator. The iterator will pass each object through the filter chain handlers before returning it.</p>"},{"location":"reference/File-Processing/#osmium.zip_processors","title":"<code>osmium.zip_processors(*procs: FileProcessor) -&gt; Iterable[List[Optional[OSMEntity]]]</code>","text":"<p>Return the data from the FileProcessors in parallel such that objects with the same ID are returned at the same time.</p> <p>The processors must contain sorted data or the results are undefined.</p>"},{"location":"reference/Filters/","title":"Filters","text":""},{"location":"reference/Filters/#osmium.filter.EmptyTagFilter","title":"<code>osmium.filter.EmptyTagFilter</code>","text":"<p>               Bases: <code>osmium._osmium.BaseFilter</code></p> <p>Filter class which only lets pass objects which have at least one tag.</p>"},{"location":"reference/Filters/#osmium.filter.EmptyTagFilter.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Create a new filter object.</p>"},{"location":"reference/Filters/#osmium.filter.EntityFilter","title":"<code>osmium.filter.EntityFilter</code>","text":"<p>               Bases: <code>osmium._osmium.BaseFilter</code></p> <p>Filter class which lets pass objects according to their type.</p>"},{"location":"reference/Filters/#osmium.filter.EntityFilter.__init__","title":"<code>__init__(entities: osm_entity_bits) -&gt; None</code>","text":"<p>Crate a new filter object. Only objects whose type is listed in entities can pass the filter.</p>"},{"location":"reference/Filters/#osmium.filter.GeoInterfaceFilter","title":"<code>osmium.filter.GeoInterfaceFilter</code>","text":"<p>               Bases: <code>osmium._osmium.BaseFilter</code></p> <p>Filter class, which adds a geo_interface attribute to object which have geometry information.</p> <p>The filter can process node, way and area types. All other types will be dropped. To create geometries for ways, the location cache needs to be enabled. Relations and closed ways can only be transformed to polygons when the area handler is enabled.</p>"},{"location":"reference/Filters/#osmium.filter.GeoInterfaceFilter.__init__","title":"<code>__init__(drop_invalid_geometries: bool = ..., tags: Iterable[str] = ...) -&gt; None</code>","text":"<p>Create a new filter object. The filter will usually drop all objects that do not have a geometry. Set drop_invalid_geometries to <code>False</code> to just let them pass.</p> <p>The filter will normally add all tags it finds as properties to the GeoInterface output. To filter the tags to relevant ones, set tags to the desired list.</p>"},{"location":"reference/Filters/#osmium.filter.IdFilter","title":"<code>osmium.filter.IdFilter</code>","text":"<p>               Bases: <code>osmium._osmium.BaseFilter</code></p> <p>Filter class which only lets pass objects with given IDs.</p> <p>This filter usually only makes sense when used together with a type restriction, set using <code>enable_for()</code>.</p>"},{"location":"reference/Filters/#osmium.filter.IdFilter.__init__","title":"<code>__init__(ids: Iterable[int]) -&gt; None</code>","text":"<p>Create a new filter object. ids contains the IDs the filter should let pass. It can be any iterable over ints.</p>"},{"location":"reference/Filters/#osmium.filter.KeyFilter","title":"<code>osmium.filter.KeyFilter</code>","text":"<p>               Bases: <code>osmium._osmium.BaseFilter</code></p> <p>Filter class which lets objects pass which have tags with at least one of the listed keys.</p> <p>This filter functions like an OR filter. To create an AND filter (a filter that lets object pass that have tags with all the listed keys) you need to chain multiple KeyFilter objects.</p>"},{"location":"reference/Filters/#osmium.filter.KeyFilter.__init__","title":"<code>__init__(*keys: str) -&gt; None</code>","text":"<p>Create a new filter object. The parameters list the keys by which the filter should choose the objects. At least one key is required.</p>"},{"location":"reference/Filters/#osmium.filter.TagFilter","title":"<code>osmium.filter.TagFilter</code>","text":"<p>               Bases: <code>osmium._osmium.BaseFilter</code></p> <p>Filter class which lets objects pass which have tags with at least one of the listed key-value pair.</p> <p>This filter functions like an OR filter. To create an AND filter (a filter that lets object pass that have tags with all the listed key-value pairs) you need to chain multiple TagFilter objects.</p>"},{"location":"reference/Filters/#osmium.filter.TagFilter.__init__","title":"<code>__init__(*tags: Tuple[str, str]) -&gt; None</code>","text":"<p>Create a new filter object. The parameters list the key-value pairs by which the filter should choose objects. Each pair must be a tuple with two strings and at least one pair is required.</p>"},{"location":"reference/Geometry-Functions/","title":"Geometry builders and functions","text":""},{"location":"reference/Geometry-Functions/#osmium.geom.FactoryProtocol","title":"<code>osmium.geom.FactoryProtocol</code>","text":"<p>Protocol for classes that implement the necessary functions for converting OSM objects into simple-feature-like geometries.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.FactoryProtocol.epsg","title":"<code>epsg: int</code>  <code>property</code>","text":"<p>Projection of the output geometries as a EPSG number.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.FactoryProtocol.proj_string","title":"<code>proj_string: str</code>  <code>property</code>","text":"<p>Projection of the output geometries as a projection string.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.FactoryProtocol.create_linestring","title":"<code>create_linestring(line: LineStringLike, use_nodes: use_nodes = ..., direction: direction = ...) -&gt; str</code>","text":"<p>Create a line string geometry from a way like object. This may be a Way or a WayNodeList. Subsequent nodes with the exact same coordinates will be filtered out because many tools consider repeated coordinates in a line string invalid. Set use_nodes to <code>osmium.geom.ALL</code> to suppress this behaviour.</p> <p>The line string usually follows the order of the node list. Set direction to <code>osmium.geom.BACKWARDS</code> to inverse the direction.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.FactoryProtocol.create_multipolygon","title":"<code>create_multipolygon(area: osmium.osm.Area) -&gt; str</code>","text":"<p>Create a multi-polygon geometry from an Area object.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.FactoryProtocol.create_point","title":"<code>create_point(location: PointLike) -&gt; str</code>","text":"<p>Create a point geometry from a Node, a location or a node reference.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.Coordinates","title":"<code>osmium.geom.Coordinates</code>","text":"<p>Represent a x/y coordinate. The projection of the coordinate is left to the interpretation of the caller.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.Coordinates.x","title":"<code>x: float</code>  <code>property</code>","text":"<p>x portion of the coordinate.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.Coordinates.y","title":"<code>y: float</code>  <code>property</code>","text":"<p>y portion of the coordinate.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.Coordinates.valid","title":"<code>valid() -&gt; bool</code>","text":"<p>Return true if the coordinate is valid. A coordinate can only be invalid when both x and y are NaN.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.GeoJSONFactory","title":"<code>osmium.geom.GeoJSONFactory</code>","text":"<p>               Bases: <code>osmium.geom.FactoryProtocol</code></p> <p>Factory that creates GeoJSON geometries from osmium geometries.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.WKBFactory","title":"<code>osmium.geom.WKBFactory</code>","text":"<p>               Bases: <code>osmium.geom.FactoryProtocol</code></p> <p>Factory that creates WKB from osmium geometries.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.WKTFactory","title":"<code>osmium.geom.WKTFactory</code>","text":"<p>               Bases: <code>osmium.geom.FactoryProtocol</code></p> <p>Factory that creates WKT from osmium geometries.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.direction","title":"<code>osmium.geom.direction</code>","text":""},{"location":"reference/Geometry-Functions/#osmium.geom.use_nodes","title":"<code>osmium.geom.use_nodes</code>","text":""},{"location":"reference/Geometry-Functions/#geometry-functions","title":"Geometry functions","text":""},{"location":"reference/Geometry-Functions/#osmium.geom.lonlat_to_mercator","title":"<code>osmium.geom.lonlat_to_mercator(coordinate: Coordinates) -&gt; Coordinates</code>","text":"<p>Convert coordinates from WGS84 to Mercator projection.</p>"},{"location":"reference/Geometry-Functions/#osmium.geom.mercator_to_lonlat","title":"<code>osmium.geom.mercator_to_lonlat(coordinate: Coordinates) -&gt; Coordinates</code>","text":"<p>Convert coordinates from WGS84 to Mercator projection.</p>"},{"location":"reference/Handler-Processing/","title":"Handlers and Handler Functions","text":""},{"location":"reference/Handler-Processing/#osmium.SimpleHandler","title":"<code>osmium.SimpleHandler</code>","text":"<p>The most generic of OSM data handlers. Derive your data processor from this class and implement callbacks for each object type you are interested in. The following data types are recognised:</p> <p><code>node</code>, <code>way</code>, <code>relation</code>, <code>area</code> and <code>changeset</code></p> <p>A callback takes exactly one parameter which is the object. Note that all objects that are handed into the handler are only readable and are only valid until the end of the callback is reached. Any data that should be retained must be copied into other data structures.</p>"},{"location":"reference/Handler-Processing/#osmium.SimpleHandler.apply_buffer","title":"<code>apply_buffer(buffer: Buffer, format: str, locations: bool = False, idx: str = 'flex_mem', filters: List[HandlerLike] = []) -&gt; None</code>","text":"<p>Apply the handler to a string buffer. The buffer must be a byte string.</p>"},{"location":"reference/Handler-Processing/#osmium.SimpleHandler.apply_file","title":"<code>apply_file(filename: Union[str, os.PathLike[str], File], locations: bool = False, idx: str = 'flex_mem', filters: List[HandlerLike] = []) -&gt; None</code>","text":"<p>Apply the handler to the given file. If locations is true, then a location handler will be applied before, which saves the node positions. In that case, the type of this position index can be further selected in idx. If an area callback is implemented, then the file will be scanned twice and a location handler and a handler for assembling multipolygons and areas from ways will be executed.</p>"},{"location":"reference/Handler-Processing/#osmium.SimpleHandler.enabled_for","title":"<code>enabled_for() -&gt; osm_entity_bits</code>","text":"<p>Return the list of OSM object types this handler will handle.</p>"},{"location":"reference/Handler-Processing/#osmium.MergeInputReader","title":"<code>osmium.MergeInputReader</code>","text":"<p>Buffer which collects data from multiple input files, sorts it and optionally deduplicates the data before applying to a handler.</p>"},{"location":"reference/Handler-Processing/#osmium.MergeInputReader.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize a new reader.</p>"},{"location":"reference/Handler-Processing/#osmium.MergeInputReader.add_buffer","title":"<code>add_buffer(buffer: Union[ByteString, str], format: str) -&gt; int</code>","text":"<p>Add input data from a buffer to the reader. The buffer may be any data which follows the Python buffer protocol. The mandatory format parameter describes the format of the data.</p> <p>The data will be copied into internal buffers, so that the input buffer can be safely discarded after the function has been called.</p>"},{"location":"reference/Handler-Processing/#osmium.MergeInputReader.add_file","title":"<code>add_file(file: str) -&gt; int</code>","text":"<p>Add data from the given input file file to the reader.</p>"},{"location":"reference/Handler-Processing/#osmium.MergeInputReader.apply","title":"<code>apply(*handlers: HandlerLike, idx: str = '', simplify: bool = True) -&gt; None</code>","text":"<p>Apply collected data to a handler. The data will be sorted first. If simplify is true (default) then duplicates will be eliminated and only the newest version of each object kept. If idx is given a node location cache with the given type will be created and applied when creating the ways. Note that a diff file normally does not contain all node locations to reconstruct changed ways. If the full way geometries are needed, create a persistent node location cache during initial import of the area and reuse it when processing diffs. After the data has been applied the buffer of the MergeInputReader is empty and new data can be added for the next round of application.</p>"},{"location":"reference/Handler-Processing/#osmium.MergeInputReader.apply_to_reader","title":"<code>apply_to_reader(reader: Reader, writer: Writer, with_history: bool = ...) -&gt; None</code>","text":"<p>Apply the collected data to data from the given reader and write the result to writer. This function can be used to merge the diff \" data together with other OSM data (for example when updating a planet file. If with_history is true, then the collected data will be applied verbatim without removing duplicates. This is important when using OSM history files as input.</p>"},{"location":"reference/Handler-Processing/#osmium.NodeLocationsForWays","title":"<code>osmium.NodeLocationsForWays</code>","text":"<p>               Bases: <code>osmium._osmium.BaseHandler</code></p> <p>Handler for retriving and caching locations from ways and adding them to ways.</p>"},{"location":"reference/Handler-Processing/#osmium.NodeLocationsForWays.apply_nodes_to_ways","title":"<code>apply_nodes_to_ways: bool</code>  <code>property</code> <code>writable</code>","text":"<p>When set (the default), the collected locations are propagated to the node list of ways.</p>"},{"location":"reference/Handler-Processing/#osmium.NodeLocationsForWays.__init__","title":"<code>__init__(locations: LocationTable) -&gt; None</code>","text":"<p>Initiate a new handler using the given location table locations to cache the node coordinates.</p>"},{"location":"reference/Handler-Processing/#osmium.NodeLocationsForWays.ignore_errors","title":"<code>ignore_errors() -&gt; None</code>","text":"<p>Disable raising an exception when filling the node list of a way and a coordinate is not available.</p>"},{"location":"reference/Handler-Processing/#handler-functions","title":"Handler functions","text":""},{"location":"reference/Handler-Processing/#osmium.apply","title":"<code>osmium.apply(reader: Union[Reader, str, os.PathLike[str], File, FileBuffer], *handlers: HandlerLike) -&gt; None</code>","text":"<p>Apply a chain of handlers to the given input source. The input source may be a osmium.io.Reader, a file or a file buffer. If one of the handlers is a filter, then processing of the object will be stopped when it does not pass the filter.</p>"},{"location":"reference/Handler-Processing/#osmium.make_simple_handler","title":"<code>osmium.make_simple_handler(node: HandlerFunc[Node] = None, way: HandlerFunc[Way] = None, relation: HandlerFunc[Relation] = None, area: HandlerFunc[Area] = None, changeset: HandlerFunc[Changeset] = None) -&gt; SimpleHandler</code>","text":"<p>(deprecated) Convenience function that creates a SimpleHandler from a set of callback functions. Each of the parameters takes an optional callable that must expect a single positional parameter with the object being processed.</p>"},{"location":"reference/IO/","title":"IO classes","text":""},{"location":"reference/IO/#osmium.io.File","title":"<code>osmium.io.File</code>","text":"<p>A wrapper for an OSM data file.</p>"},{"location":"reference/IO/#osmium.io.File.has_multiple_object_versions","title":"<code>has_multiple_object_versions: bool</code>  <code>property</code> <code>writable</code>","text":"<p>True when the file is in a data format which supports having multiple versions of the same object in the file. This is usually the case with OSM history and diff files.</p>"},{"location":"reference/IO/#osmium.io.File.__init__","title":"<code>__init__(filename: Union[str, os.PathLike[str]], format: str = '') -&gt; None</code>","text":"<p>Initialise a new file object. Normally the file format of the file is guessed from the suffix of the file name. It may also be set explicitly using the format parameter.</p>"},{"location":"reference/IO/#osmium.io.File.parse_format","title":"<code>parse_format(format: str) -&gt; None</code>","text":"<p>Set the format of the file from a format string.</p>"},{"location":"reference/IO/#osmium.io.FileBuffer","title":"<code>osmium.io.FileBuffer</code>","text":"<p>A wrapper around a buffer containing OSM data.</p>"},{"location":"reference/IO/#osmium.io.FileBuffer.has_multiple_object_versions","title":"<code>has_multiple_object_versions: bool</code>  <code>property</code> <code>writable</code>","text":"<p>True when the file is in a data format which supports having multiple versions of the same object in the file. This is usually the case with OSM history and diff files.</p>"},{"location":"reference/IO/#osmium.io.FileBuffer.__init__","title":"<code>__init__(buf: Buffer, format: str) -&gt; None</code>","text":"<p>Initialise a new buffer object. buf can be any buffer that adheres to the Python buffer protocol. The format of the data must be defined in the format parameter.</p>"},{"location":"reference/IO/#osmium.io.FileBuffer.parse_format","title":"<code>parse_format(format: str) -&gt; None</code>","text":"<p>Set the format of the file from a format string.</p>"},{"location":"reference/IO/#osmium.io.Header","title":"<code>osmium.io.Header</code>","text":"<p>File header data with global information about the file.</p>"},{"location":"reference/IO/#osmium.io.Header.has_multiple_object_versions","title":"<code>has_multiple_object_versions: bool</code>  <code>property</code> <code>writable</code>","text":"<p>True when the file is in a data format which supports having multiple versions of the same object in the file. This is usually the case with OSM history and diff files.</p>"},{"location":"reference/IO/#osmium.io.Header.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initiate an empty header.</p>"},{"location":"reference/IO/#osmium.io.Header.add_box","title":"<code>add_box(box: Box) -&gt; Header</code>","text":"<p>Add the given bounding box to the list of bounding boxes saved in the header.</p>"},{"location":"reference/IO/#osmium.io.Header.box","title":"<code>box() -&gt; Box</code>","text":"<p>Return the bounding box of the data in the file. If no such information is available, an invalid box is returned.</p>"},{"location":"reference/IO/#osmium.io.Header.get","title":"<code>get(key: str, default: str = ...) -&gt; str</code>","text":"<p>Get the value of header option key or return default if there is no header option with that name.</p>"},{"location":"reference/IO/#osmium.io.Header.set","title":"<code>set(key: str, value: str) -&gt; None</code>","text":"<p>Set the value of header option key to value.</p>"},{"location":"reference/IO/#osmium.io.Reader","title":"<code>osmium.io.Reader</code>","text":"<p>Low-level object for reading data from an OSM file.</p> <p>A Reader does not expose functions to process the data it has read from the file. Use apply for that purpose.</p>"},{"location":"reference/IO/#osmium.io.Reader.__init__","title":"<code>__init__(filename: Union[str, os.PathLike[str], FileBuffer, File], types: osm_entity_bits = ...) -&gt; None</code>","text":"<p>Create a new reader object. The input may either be a filename or a File or FileBuffer object. The types parameter defines which kinds of objects will be read from the input. Any types not present will be skipped completely when reading the file. Depending on the type of input, this can save quite a bit of time. However, be careful to not skip over types that may be referenced by other objects. For example, ways need nodes in order to compute their geometry.</p> <p>Readers may be used as a context manager. In that case, the <code>close()</code> function will be called automatically when the reader leaves the scope.</p>"},{"location":"reference/IO/#osmium.io.Reader.close","title":"<code>close() -&gt; None</code>","text":"<p>Close any open file handles and free all resources. The Reader is unusuable afterwards.</p>"},{"location":"reference/IO/#osmium.io.Reader.eof","title":"<code>eof() -&gt; bool</code>","text":"<p>Check if the reader has reached the end of the input data.</p>"},{"location":"reference/IO/#osmium.io.Reader.header","title":"<code>header() -&gt; Header</code>","text":"<p>Return the Header structure containing global information about the input. What information is available depends on the format of the input data.</p>"},{"location":"reference/IO/#osmium.io.Writer","title":"<code>osmium.io.Writer</code>","text":"<p>Low-level object for writing OSM data into a file. This class does not expose functions for receiving data to be written. Have a look at SimpleWriter for a higher-level interface for writing data.</p>"},{"location":"reference/IO/#osmium.io.Writer.__init__","title":"<code>__init__(ffile: Union[str, os.PathLike[str], File], header: Header = ...) -&gt; None</code>","text":"<p>Create a new Writer. The output may either be a simple filename or a File object. A custom Header object may be given, to customize the global file information that is written out. Be aware that not all file formats support writing out all header information.</p>"},{"location":"reference/IO/#osmium.io.Writer.close","title":"<code>close() -&gt; int</code>","text":"<p>Close any open file handles and free all resources. The Writer is unusable afterwards.</p>"},{"location":"reference/Indexes/","title":"Indexes","text":""},{"location":"reference/Indexes/#osmium.IdTracker","title":"<code>osmium.IdTracker</code>","text":"<p>Class to keep track of node, way and relation IDs.</p> <p>Ids can be added to the to the tracker in various ways: by adding IDs directly, by adding the IDs of referenced IDs in an OSM object or by extracting the referenced IDs from an input file.</p> <p>The tracker can then be used as a filter to select objects based on whether they are contained in the tracker's ID lists.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialise a new empty tracker.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.add_node","title":"<code>add_node(node: int) -&gt; None</code>","text":"<p>Add the given node ID to the tracker.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.add_references","title":"<code>add_references(obj: object) -&gt; None</code>","text":"<p>Add all IDs referenced by the input object obj.</p> <p>The function will track the IDs of node lists from Way objects or Python objects with a <code>nodes</code> attribute, which must be a sequence of ints. It also tracks the IDs of relation members from Relation objects or Python objects with a <code>members</code> attribute with an equivalent content. Input objects that do not fall into any of these categories are silently ignored.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.add_relation","title":"<code>add_relation(relation: int) -&gt; None</code>","text":"<p>Add the given relation ID to the tracker.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.add_way","title":"<code>add_way(way: int) -&gt; None</code>","text":"<p>Add the given way ID to the tracker.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.complete_backward_references","title":"<code>complete_backward_references(filename: Union[str, os.PathLike[str], File, FileBuffer], relation_depth: int = ...) -&gt; None</code>","text":"<p>Make the IDs in the tracker reference-complete by adding all referenced IDs for objects whose IDs are already tracked.</p> <p>The function scans through the reference file <code>filename</code>, finds all the objects this tracker references and applies <code>add_references()</code> to them. The reference file is expected to be sorted.</p> <p>The relation_depth parameter controls how nested relations are handled. When set to 0 then only way and node references of relations that are already tracked are completed. If the parameter is larger than 0, the function will make at a maximum relation_depth passes through the reference file, to find nested relation. That means, that nested relations with a nesting depth up to relation_depth are guaranteed to be included. Relations that are nested more deeply, may or may not appear.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.complete_forward_references","title":"<code>complete_forward_references(filename: Union[str, os.PathLike[str], File, FileBuffer], relation_depth: int = ...) -&gt; None</code>","text":"<p>Add to the tracker all IDs of object that reference any ID already tracked.</p> <p>The function scans through the reference file <code>filename</code>, checks all objects in the file with the <code>contains_any_references()</code> function and adds the object ID to the tracker if the check is positive.</p> <p>The relation_depth parameter controls how nested relations are handled. When set to a value smaller than 0, then relations will no be added at all to the tracker. When set to 0, then only relations are added that reference a node or way already in the tracker. When set to a strictly positive value, then nested relations are tacken into account as well. The function will make at a maximum relation_depth passes to complete relations with relation members.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.contains_any_references","title":"<code>contains_any_references(obj: object) -&gt; bool</code>","text":"<p>Check if the given input object obj contains any references to IDs tracked by this tracker.</p> <p>The function will check the IDs of node lists from Way objects or Python objects with a <code>nodes</code> attribute, which must be a sequence of ints. It also tracks the IDs of relation members from Relation objects or Python objects with a <code>members</code> attribute with an equivalent content. All other object kinds will return <code>False</code>.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.contains_filter","title":"<code>contains_filter() -&gt; IdTrackerContainsFilter</code>","text":"<p>Return a filter object that lets all ways and relations pass which reference any of the object IDs tracked by this tracker.</p> <p>You may change the tracker while the filter is in use. Such a change is then immediately reflected in the filter.</p> <p>The filter has no effect on nodes, areas and changesets.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.id_filter","title":"<code>id_filter() -&gt; IdTrackerIdFilter</code>","text":"<p>Return a filter object which lets all nodes, ways and relations pass that are being tracked in this tracker.</p> <p>You may change the tracker while the filter is in use. Such a change is then immediately reflected in the filter.</p> <p>The filter has no effect on areas and changesets.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.node_ids","title":"<code>node_ids() -&gt; IdSet</code>","text":"<p>Return a view of the set of node ids. The returned object is mutable. You may call operations like <code>unset()</code> and <code>clear()</code> on it, which then have a direct effect on the tracker.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.relation_ids","title":"<code>relation_ids() -&gt; IdSet</code>","text":"<p>Return a view of the set of relation ids. The returned object is mutable. You may call operations like <code>unset()</code> and <code>clear()</code> on it, which then have a direct effect on the tracker.</p>"},{"location":"reference/Indexes/#osmium.IdTracker.way_ids","title":"<code>way_ids() -&gt; IdSet</code>","text":"<p>Return a view of the set of way ids.The returned object is mutable. You may call operations like <code>unset()</code> and <code>clear()</code> on it, which then have a direct effect on the tracker.</p>"},{"location":"reference/Indexes/#osmium.index.IdSet","title":"<code>osmium.index.IdSet</code>","text":"<p>Compact storage for a set of IDs.</p>"},{"location":"reference/Indexes/#osmium.index.IdSet.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialise an empty set.</p>"},{"location":"reference/Indexes/#osmium.index.IdSet.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Remove all IDs from the set.</p>"},{"location":"reference/Indexes/#osmium.index.IdSet.empty","title":"<code>empty() -&gt; bool</code>","text":"<p>Check if no IDs are stored yet.</p>"},{"location":"reference/Indexes/#osmium.index.IdSet.get","title":"<code>get(id: int) -&gt; bool</code>","text":"<p>Check if the given ID is in the storage.</p>"},{"location":"reference/Indexes/#osmium.index.IdSet.set","title":"<code>set(id: int) -&gt; None</code>","text":"<p>Add an ID to the storage. Does nothing if the ID is already contained.</p>"},{"location":"reference/Indexes/#osmium.index.IdSet.unset","title":"<code>unset(id: int) -&gt; None</code>","text":"<p>Remove an ID from the storage. Does nothing if the ID is not in the storage.</p>"},{"location":"reference/Indexes/#osmium.index.LocationTable","title":"<code>osmium.index.LocationTable</code>","text":"<p>A map from a node ID to a location object. Location can be set and queried using the standard [] notation for dicts. This implementation works only with positive node IDs.</p>"},{"location":"reference/Indexes/#osmium.index.LocationTable.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Remove all entries from the location table..</p>"},{"location":"reference/Indexes/#osmium.index.LocationTable.get","title":"<code>get(id: int) -&gt; osmium.osm.Location</code>","text":"<p>Get the location for the given node ID. Raises a <code>KeyError</code> when there is no location for the given id.</p>"},{"location":"reference/Indexes/#osmium.index.LocationTable.set","title":"<code>set(id: int, loc: osmium.osm.Location) -&gt; None</code>","text":"<p>Set the location for the given node ID.</p>"},{"location":"reference/Indexes/#osmium.index.LocationTable.used_memory","title":"<code>used_memory() -&gt; int</code>","text":"<p>Return the size (in bytes) currently allocated by this location table.</p>"},{"location":"reference/Indexes/#index-creation-functions","title":"Index creation functions","text":""},{"location":"reference/Indexes/#osmium.index.map_types","title":"<code>osmium.index.map_types() -&gt; List[str]</code>","text":"<p>Return a list of strings with valid types for the location table.</p>"},{"location":"reference/Indexes/#osmium.index.create_map","title":"<code>osmium.index.create_map(map_type: str) -&gt; LocationTable</code>","text":"<p>Create a new location store. Use the map_type parameter to choose a concrete implementation. Some implementations take additiona configuration parameters, which can also be set through the map_type argument. For example, to create an array cache backed by a file 'foo.store', the map_type needs to be set to <code>dense_file_array,foo.store</code>. Read the section on location storage in the user manual for more information about the different implementations.</p>"},{"location":"user_manual/01-First-Steps/","title":"First Steps","text":"<p>pyosmium is a library that processes data as a stream: it reads the data from a file or other input source and presents the data to the user one object at the time. This means that it can efficiently process large files with many objects. The down-side is that it is not possible to directly access specific objects as you need them. Instead it is necessary to apply some simple techniques of caching and repeated reading of files to get all the data you need. This takes some getting used to at the beginning but pyosmium gives you the necessary tools to make it easy.</p>"},{"location":"user_manual/01-First-Steps/#file-processing","title":"File processing","text":"<p>pyosmium allows to process OSM files just like any other file: Open the file by instantiating a FileProcessor, then iterate over each OSM object in the file with a simple 'for' loop.</p> <p>Lets start with a very simple script that lists the contents of file:</p> <p>Example</p> Code <pre><code>import osmium\n\nfor obj in osmium.FileProcessor('buildings.opl'):\n    print(obj)\n</code></pre> Output <pre><code>n1: location=45.0000000/13.0000000 tags={}\nn2: location=45.0001000/13.0000000 tags={}\nn3: location=45.0001000/13.0001000 tags={}\nn4: location=45.0000000/13.0001000 tags={entrance=yes}\nn11: location=45.0000000/13.0000000 tags={}\nn12: location=45.0000500/13.0000000 tags={}\nn13: location=45.0000500/13.0000500 tags={}\nn14: location=45.0000000/13.0000500 tags={}\nw1: nodes=[1,2,3,4,1] tags={}\nw2: nodes=[11,12,13,14,11] tags={}\nr1: members=[w1,w2], tags={type=multipolygon,building=yes}\n</code></pre> <p>While iterating over the file, pyosmium decodes the data from the file in the background and puts it into a buffer. It then returns a read-only view of each OSM object to Python. This is important to always keep in mind. pyosmium never shows you a full data object, it only ever presents a view. That means you can read and process the information about the object but you cannot change it or keep the object around for later. Once you retrieve the next object, the view will no longer be valid.</p> <p>To show you what happens, when you try to keep the objects around, let us slightly modify the example above. Say you want to have a more compact output and just print for each object type, which IDs appear in the file. You might be tempted to just save the object and create the formatted output only after reading the file is done:</p> <p>Buggy Example</p> Code <pre><code># saves object by their type, more about types later\nobjects = {'n' : [], 'w': [], 'r': []}\n\nfor obj in osmium.FileProcessor('buildings.opl'):\n    objects[obj.type_str()].append(obj)\n\nfor otype, olist in objects.items():\n    print(f\"{otype}: {','.join(o.id for o in olist)}\")\n</code></pre> Output <pre><code>Traceback (most recent call last):\n  File \"bad_ref.py\", line 10, in &lt;module&gt;\n    print(f\"{otype}: {','.join(o.id for o in olist)}\")\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"bad_ref.py\", line 10, in &lt;genexpr&gt;\n    print(f\"{otype}: {','.join(o.id for o in olist)}\")\n                               ^^^^\n  File \"osmium/osm/types.py\", line 313, in id\n    return self._pyosmium_data.id()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: Illegal access to removed OSM object\n</code></pre> <p>As you can see, the code throws a runtime error complaining about an 'illegal access'. The <code>objects</code> dictionary doesn't contain any OSM objects. It just has collected all the views on the objects. By the time the view is accessed in the print function, the buffer the view points to is long gone. pyosmium has invalidated the view. In practise this means that you need to make an explicit copy of all information you need outside the loop iteration.</p> <p>The code above can be easily \"fixed\" by saving only the id instead of the full object. This also happens to be much more memory efficient:</p> <p>Example</p> Code <pre><code>objects = {'n' : [], 'w': [], 'r': []}\n\nfor obj in osmium.FileProcessor('buildings.opl'):\n    objects[obj.type_str()].append(obj.id)\n\nfor otype, olist in objects.items():\n    print(f\"{otype}: {','.join(str(id) for id in olist)}\")\n</code></pre> Output <pre><code>n: 1,2,3,4,11,12,13,14\nw: 1,2\nr: 1\n</code></pre> <p>The output shows IDs for three different kind of objects: nodes, ways and relations. Before we can continue, you need to understand the basics about these types of objects and of the OpenStreetMap data model. If you are already familiar with the structure of OSM data, you can go directly to the next chapter.</p>"},{"location":"user_manual/01-First-Steps/#osm-data-model","title":"OSM data model","text":"<p>OpenStreetMap data is organised as a topological model. Objects are not described with geometries like most GIS models do. Instead the objects are described in how they relate to points in the world. This makes a huge difference in how the data is processed.</p> <p>An OSM object does not have a pre-defined function. What an object represents is described with a set of properties, the tags. This is a simple key-value store of strings. The meaning of the tags is not part of the data model definition. Except for some minor technical limits, for example a maximum length, any string can appear in the key and value of the tags. What keys and values are used is decided through consensus between users. This gives OSM a great flexibility to experiment with new kinds of data and evolve its dataset. Over time a large set of agreed-upon tags has emerged for most kinds of objects. These are the tags you will usually work with. You can search the documentation in the OSM Wiki to find out about the tags. It is also always useful to consult Taginfo, which shows statistics over the different keys and value in actual use.</p> <p>Tags are common to all OSM objects. After that there are three kinds of objects in OSM: nodes, ways and relations.</p>"},{"location":"user_manual/01-First-Steps/#nodes","title":"Nodes","text":"<p>A node is a point on the surface of the earth. Its location is described through its latitude and longitude using projection WSG84.</p>"},{"location":"user_manual/01-First-Steps/#ways","title":"Ways","text":"<p>Ways are lines that are created by connecting a sequence of nodes. The nodes are described with the ID of a node in the database. That means that a way object does not directly have coordinates. To find out about the coordinates where the way is located, it is necessary to look up the nodes of the way in the database and get their coordinates.</p> <p>Representing a way through nodes has another interesting side effect: many of the nodes in OSM are not meaningful in itself. They don't represent a bus stop or lamp post or entrance or any other point of interest. They only exist as supporting points for the ways and don't have any tags.</p> <p>When a way ends at the same node ID where it starts, then the way may be interpreted as representing an area. If it is really an area or just a linear feature that happens to circle back on itself (for example, a fence around a garden) depends on the tags of the way. Areas are handled more in-depth in the chapter Working with Geometries.</p>"},{"location":"user_manual/01-First-Steps/#relations","title":"Relations","text":"<p>A relation is an ordered collection of objects. Nodes, ways and relations all can be a member in a relation. In addition, a relation member can be assigned a role, a string that describes the function of a member. The data model doesn't define what relations should be used for or how the members should be interpreted.</p>"},{"location":"user_manual/01-First-Steps/#forward-and-backward-references","title":"Forward and backward references","text":"<p>The topologic nature of the OSM data model means that an OSM object rarely can be regarded in isolation. OSM ways are not meaningful without the location information contained in its nodes. And conversely, changing the location in a way also changes the geometry of the way even though the way itself is not changed. This is an important concept to keep in mind when working with OSM data. In this manual, we will use the terms forward and backward references when talking about the dependencies between objects:</p> <ul> <li> <p>A forward reference means that an object is referenced to by another.   Nodes appear in ways. Ways appear in relations. And a node may even have   an indirect forward reference to a relation through a way it appear in.   Forward references are important when tracking changes. When the location   of a node changes, then all its forward references have to be reevaluated.</p> </li> <li> <p>A backward reference goes from an object to its referenced children.   Going from a way to its containing nodes means following a backward   reference. Backward references are needed to get the complete geometry of   an object: given that only nodes contain location information, we have   to follow the backward references for ways and relations until we reach   the nodes.</p> </li> </ul>"},{"location":"user_manual/01-First-Steps/#order-in-osm-files","title":"Order in OSM files","text":"<p>OSM files usually follow a sorting convention to make life easier for processing software: first come nodes, then ways, then relations. Each group of objects is ordered by ID. One of the advantages of this order is that you can be sure that you have been already presented with all backward references to an object, when it appears in the processing loop. Knowing this fact can help you optimise how often you have to read through the file and speed up processing.</p> <p>Sadly, there is an exception to the rule which is nested relations: relations can of course contain other relations with a higher ID. If you have to work with nested relations, rescanning the file multiple times or keeping large parts of the file in memory is pretty much always unavoidable.</p>"},{"location":"user_manual/02-Extracting-Object-Data/","title":"OSM Objects","text":"<p>This chapter explains more about the different object types that are returned in pyosmium and how to access its data.</p>"},{"location":"user_manual/02-Extracting-Object-Data/#determining-the-type-of-object","title":"Determining the Type of Object","text":"<p>pyosmium may return five different types of objects. First there are the three base types from the OSM data model already introduced in the last chapter: nodes, ways and relations. Next there is an area type. It is explained in more detail in the Geometry chapter. Finally, there is a type for changesets, which contains information about edits in the OSM database. It can only appear in special changeset files and explained in more detail below.</p> <p>The FileProcessor may return any of these objects, when iterating over a file. Therefore, a script will usually first need to determine the type of object received. There are a couple of ways to do this.</p>"},{"location":"user_manual/02-Extracting-Object-Data/#using-is_-convenience-functions","title":"Using <code>is_*()</code> convenience functions","text":"<p>All object types, except changesets, implement a set of <code>is_node</code>/<code>is_way</code>/<code>is_relation</code>/<code>is_area</code> functions, which give a nicely readable way of testing for a specific object type.</p> <p>Example</p> Code <pre><code>for o in osmium.FileProcessor('buildings.opl'):\n    if o.is_relation():\n        print('Found a relation.')\n</code></pre> Output <pre><code>Found a relation.\n</code></pre>"},{"location":"user_manual/02-Extracting-Object-Data/#using-the-type-identifier","title":"Using the type identifier","text":"<p>The <code>type_str()</code> function returns the type of the object as a single lower case character. The supported types are:</p> Character Type n node w way r relation a area c changeset <p>This type string can be useful for printing or when saving data by type. It can also be used to test for a specific type. It is particularly useful when testing for multiple types:</p> <p>Example</p> Code <pre><code>for o in osmium.FileProcessor('../data/buildings.opl'):\n    if o.type_str() in 'wr':\n        print('Found a way or relation.')\n</code></pre> Output <pre><code>Found a way or relation.\nFound a way or relation.\nFound a way or relation.\n</code></pre>"},{"location":"user_manual/02-Extracting-Object-Data/#testing-for-object-type","title":"Testing for object type","text":"<p>Each OSM object type has a corresponding Python class. You can simply test for this object type:</p> <p>Example</p> <pre><code>for o in osmium.FileProcessor('buildings.opl'):\n    if isinstance(o, osmium.osm.Relation):\n        print('Found a relation.')\n</code></pre>"},{"location":"user_manual/02-Extracting-Object-Data/#reading-object-tags","title":"Reading object tags","text":"<p>Every object has a list of properties, the tags. They can be accessed through the <code>tags</code> property, which provides a simple dictionary-like view of the tags. You can use the bracket notation to access a specific tag or use the more explicit <code>get()</code> function. Just like for Python dictionaries, an access by bracket raises a <code>ValueError</code> when the key you are looking for does not exist, while the <code>get()</code> function returns the selected default value.</p> <p>The <code>in</code> operation can be used to check for existence of a key:</p> <p>Example</p> <pre><code>for o in osmium.FileProcessor('buildings.opl'):\n    # When using the bracket notation, make sure the tag exists.\n    if 'entrance' in o.tags:\n        print('entrace =', o.tags['entrance'])\n\n    # The get() function never throws.\n    print('building =', o.tags.get('building', '&lt;unset&gt;')\n</code></pre> <p>Tags can also be iterated over. The iterator returns Tag objects. These each hold a key (<code>k</code>) and a value (<code>v</code>) string. A tag is itself a Python iterable, so that you can easily iterate through keys and values like this:</p> <p>Example</p> <pre><code>from collections import Counter\n\nstats = Counter()\n\nfor o in osmium.FileProcessor('buildings.opl'):\n    for k, v in o.tags:\n        stats.update([(k, v)])\n\nprint(\"Most common tags:\", stats.most_common(3))\n</code></pre> <p>As with all data in OSM objects, the tags property is only a view on tags of the object. If you want to save the tag list for later use, you must make a copy of the list. The most simple way to do this, is to convert the tag list into a Python dictionary:</p> <p>Example</p> <pre><code>saved_tags = []\n\nfor o in osmium.FileProcessor('../data/buildings.opl'):\n    if o.tags:\n        saved_tags.append(dict(o.tags))\n\nprint(\"Saved tags:\", saved_tags)\n</code></pre>"},{"location":"user_manual/02-Extracting-Object-Data/#other-common-meta-information","title":"Other common meta information","text":"<p>Next to the tags, every OSM object also carries some meta information describing its ID, version and information regarding the editor.</p>"},{"location":"user_manual/02-Extracting-Object-Data/#properties-of-osm-object-types","title":"Properties of OSM object types","text":""},{"location":"user_manual/02-Extracting-Object-Data/#nodes","title":"Nodes","text":"<p>The main property of a Node is the location, a coordinate in WGS84 projection. Latitude and longitude of the node can be accessed either through the <code>location</code> property or through the <code>lat</code> and <code>lon</code> shortcuts:</p> <p>Example</p> <pre><code>for o in osmium.FileProcessor('../data/buildings.opl', osmium.osm.NODE):\n    assert (o.location.lon, o.location.lat) == (o.lon, o.lat)\n</code></pre> <p>OpenStreetMap, and by extension pyosmium, saves latitude and longitude internally as a 7-digit fixed-point number. You can access the coordinates as fixed-point integers through the <code>x</code> and <code>y</code> properties. There may be rare use cases, where using this fixed-point notation is faster and more precise.</p> <p>The coordinates returned by the <code>lat</code>/<code>lon</code> accessors are guaranteed to be valid. That means that a value is set and is between -180 and 180 degrees for longitude and -90 and 90 degrees for latitude. If the file contains an invalid coordinate, then pyosmium will throw a <code>ValueError</code>. To access the raw unchecked coordinates, use the functions <code>location.lat_without_check()</code> and <code>location.lon_without_check()</code>.</p>"},{"location":"user_manual/02-Extracting-Object-Data/#ways","title":"Ways","text":"<p>A Way is essentially an ordered sequence of nodes. This sequence can be accessed through the <code>nodes</code> property. An OSM way only stores the ID of each node. This can be rather inconvenient when you want to work with the geometry of the way, because the coordinates of each node need to be looked up. pyosmium therefore exposes a list of NodeRefs with the nodes property. Each element in this list contains the node ID and optionally the location of the node. The next chapter Working with Geometries explains in detail, how pyosmium can help to fill the location of the node.</p>"},{"location":"user_manual/02-Extracting-Object-Data/#relations","title":"Relations","text":"<p>A Relation is also an ordered sequence. Each sequence element can reference an arbitrary OSM object. In addition, each of the members can be assigned a role, an arbitrary string that describes the function of the member. The OSM data model does not specify what the function of a member is and which roles are defined. You need to know what kind of relation you are dealing with in order to understand what the members are suppose to represent. Over the years, the OSM community has established a convention that every relation comes with a <code>type</code> tag, which defines the basic kind of the relation. For each type you can refer to the Wiki documentation to learn about the meaning of members and roles. The most important types currently in use are:</p> <ul> <li>multipolygon   describes an area geometry. Pyosmium natively supports creating geometries   from this type of relation. See   Working with Geometries for more information.</li> <li>boundary    is a special form of the multipolygon type. It is used specifically for   the various forms of boundaries and define some special roles   for associated node objects.</li> <li>route is for   collections of ways that make up marked routes for hiking, cycling   and other forms of transport.</li> <li>public_transport   are a special form of the route relation made for routes of public transport   vehicles (trains, buses, trams etc). They add some special member roles   for the stops of the vehicles.</li> <li>restriction   is for street-level routing and describes turn restrictions for vehicles.</li> <li>associatedStreet   relation types are used in some parts of the world to create a connection   between address points and the street they belong to.</li> </ul> <p>The members of a relation can be accessed through the <code>members</code> property. This is a simple list of RelationMember objects. They expose the OSM type of the member, its ID and a role string. When no role has been set, the <code>role</code> property returns an empty string. Here is an example of a simple iteration over all members:</p> <p>Example</p> <pre><code>for o in osmium.FileProcessor('buildings.opl', osmium.osm.RELATION):\n    for member in o.members:\n        print(f\"Type: {member.type}  ID: {member.ref}  Role: {member.role}\")\n</code></pre> <p>The member property provides only a temporary read-only view of the members. If you want to save the list for later processing, you need to make an explicit copy like this:</p> <p>Example</p> <pre><code>memberlist = {}\n\nfor o in osmium.FileProcessor('buildings.opl', osmium.osm.RELATION):\n    memberlist[o.id] = [(m.type, m.ref, m.role) for m in o.members]\n\nprint(memberlist)\n</code></pre> <p>Always keep in mind that relations can become very large. Some have thousands of members. Therefore consider very carefully which members you are actually interested when saving members and only keep those that are actually needed later.</p>"},{"location":"user_manual/02-Extracting-Object-Data/#changeset","title":"Changeset","text":"<p>The Changeset type is the odd one out among the OSM data types. It does not contain actual map data. Instead it is use to save meta information about the edits made to the OSM database. You normally don't find Changeset objects in a datafile. Changeset information is published in separate files.</p>"},{"location":"user_manual/03-Working-with-Geometries/","title":"Working with Geometries","text":"<p>When working with map data, sooner or later, you will need the geometry of an object: a point, a line or a polygon. OSM's topologic data model doesn't make them directly available with each object. In order to build a geometry for an object, the location information from referenced nodes need to be collected and then the geometry can be assembled from that. pyosmium provides a number of data structures and helpers to create geometries for OSM objects.</p>"},{"location":"user_manual/03-Working-with-Geometries/#geometry-types","title":"Geometry types","text":""},{"location":"user_manual/03-Working-with-Geometries/#point-geometries","title":"Point geometries","text":"<p>OSM nodes are the only kind of OSM object that produce a point geometry. The location of the point is directly stored with the OSM nodes. This makes it straightforward to extract such a geometry:</p> <p>Example</p> Code <pre><code>for o in osmium.FileProcessor('buildings.opl', osmium.osm.NODE):\n    print(f\"Node {o.id}: lat = {o.lat} lon = {o.lon}\")\n</code></pre> Output <pre><code>Node 1: lat = 13.0 lon = 45.0\nNode 2: lat = 13.0 lon = 45.0001\nNode 3: lat = 13.0001 lon = 45.0001\nNode 4: lat = 13.0001 lon = 45.0\nNode 11: lat = 13.00001 lon = 45.00001\nNode 12: lat = 13.00001 lon = 45.00005\nNode 13: lat = 13.00005 lon = 45.00005\nNode 14: lat = 13.00005 lon = 45.00001\n</code></pre>"},{"location":"user_manual/03-Working-with-Geometries/#line-geometries","title":"Line geometries","text":"<p>Line geometries are usually created from OSM ways. The OSM way object does not contain the coordinates of a line geometry directly. It only contains a list of references to OSM nodes. To create a line geometry from an OSM way, it is necessary to look up the coordinate of each referenced node. pyosmium provides an efficient way to do so: the location storage. The storage automatically records the coordinates of each node that is read from the file and caches them for future use. When later a way is read from a file, the list of nodes in the way is augmented with the appropriate coordinates. Location storage is not enabled by default. To add it to the processing, use the function <code>with_locations()</code> of the FileProcessor.</p> <p>Example</p> Code <pre><code>for o in osmium.FileProcessor('../data/buildings.opl').with_locations():\n    if o.is_way():\n        coords = \", \".join((f\"{n.lon} {n.lat}\" for n in o.nodes if n.location.valid()))\n        print(f\"Way {o.id}: LINESTRING({coords})\")\n</code></pre> Output <pre><code>Way 1: LINESTRING(45.0 13.0, 45.0001 13.0, 45.0001 13.0001, 45.0 13.0001, 45.0 13.0)\nWay 2: LINESTRING(45.00001 13.00001, 45.00005 13.00001, 45.00005 13.00005, 45.00001 13.00005, 45.00001 13.00001)\n</code></pre> <p>Not all OSM files are reference-complete. It can happen that some nodes which are referenced by a way are missing from a file. Always write your code so that it can work with incomplete geometries. In particular, you should be aware that there is no guarantee that an OSM way will translate into a valid line geometry. An OSM way may consist of only one node. Or two subsequent coordinates in the line are exactly at the same position.</p> <p>pyosmium provides different implementations for the location storage. The default should be suitable for small to medium-sized OSM files. See the paragraph on Location storage below for more information on the different types of storages and how to switch them.</p>"},{"location":"user_manual/03-Working-with-Geometries/#areas","title":"Areas","text":"<p>OSM has two different ways to model area geometries: they may be derived from way objects or relation objects.</p> <p>A way can be interpreted as an area when it is closed. That happens when the first and the last node are exactly the same. You can use the function <code>is_closed()</code>.</p> <p>Not every closed way necessarily represents and area. Think of a little garden with a fence around it. If the OSM way represents the garden, then it should be interpreted as an area. If it represents the fence, then it is a line geometry that just happens to go full circle. You need to look at the tags of a way in order to decide if it should become an area or a line, or sometimes even both.</p> <p>There are two types of relations that also represent areas. If the relation is tagged with <code>type=multipolygon</code> or <code>type=boundary</code> then it is by convention an area independently of all the other tags of the relation.</p> <p>pyosmium implements a special handler for the processing of areas. This handler creates a new type of object, the Area object, and makes it available like the other OSM types. It can be enabled with the <code>with_areas()</code> function:</p> <p>Example</p> Code <pre><code>objects = ''\nareas = ''\nfor o in osmium.FileProcessor('../data/buildings.opl').with_areas():\n    objects += f\" {o.type_str()}{o.id}\"\n    if o.is_area():\n        areas += f\" {o.type_str()}{o.id}({'w' if o.from_way() else 'r'}{o.orig_id()})\"\n\nprint(\"OSM objects in this file:\", objects)\nprint(\"Areas in this file:\", areas)\n</code></pre> Output <pre><code>OSM objects in this file:  n1 n2 n3 n4 n11 n12 n13 n14 w1 w2 r1 a2 a3\nAreas in this file:  a2(w1) a3(r1)\n</code></pre> <p>Note how Area objects are added to the iterator in addition to the original OSM data. During the processing of the loop, there is first OSM way 1 and then the Area object 2, which corresponds to the same way.</p> <p>When the area handler is enabled, the FileProcessor scans the file twice: during the first run information about all relations that might be areas is collected. This information is then used in the main run of the file processor, where the areas are assembled as soon as all the necessary objects that are part of each relation have been collected.</p> <p>The area handler automatically enables a location storage because it needs access to the node geometries. It will set up the default implementation. To use a different implementation, simply use <code>with_locations()</code> with a custom storage together with <code>with_areas()</code>.</p>"},{"location":"user_manual/03-Working-with-Geometries/#the-pyosmium-area-type","title":"The pyosmium Area type","text":"<p>The Area type has the same common attributes as the other OSM types. However, it produces its own special ID space. This is necessary because an area might be originally derived from a relation or way. When derived from a way, the ID is computed as <code>2 * way ID</code>. When it is derived from a relation, the ID is <code>2 * relation ID + 1</code>. Use the function <code>from_way()</code> to check what type the original OSM object is and the function <code>orig_id()</code> to get the ID of the underlying object.</p> <p>The polygon information is organised in lists of rings. Use <code>outer_rings()</code> to iterate over the rings of the polygon that form outer boundaries of the polygon. The data structures for these rings are node lists just like the ones used in OSM ways. They always form a closed line that goes clockwise. Each outer ring can have one or more holes. These can be iterated through with the <code>inner_rings()</code> function. The inner rings are also a node list but will go anti-clockwise. To illustrate how to process the functions, here is the simplified code to create the WKT representation of the polygon:</p> <p>Example</p> Code <pre><code>for o in osmium.FileProcessor('../data/buildings.opl').with_areas():\n    if o.is_area():\n        polygons = []\n        for outer in o.outer_rings():\n            rings = \"(\" + \", \".join((f\"{n.lon} {n.lat}\" for n in outer if n.location.valid())) + \")\"\n            for inner in o.inner_rings(outer):\n                rings += \", (\" + \", \".join((f\"{n.lon} {n.lat}\" for n in outer if n.location.valid())) + \")\"\n            polygons.append(rings)\n        if o.is_multipolygon():\n            wkt = f\"MULTIPOLYGON(({'), ('.join(polygons)}))\"\n        else:\n            wkt = f\"POLYGON({polygons[0]})\"\n        print(f\"Area {o.id}: {wkt}\")        \n</code></pre> Output <pre><code>Area 2: POLYGON((45.0 13.0, 45.0001 13.0, 45.0001 13.0001, 45.0 13.0001, 45.0 13.0))\nArea 3: POLYGON((45.0 13.0, 45.0001 13.0, 45.0001 13.0001, 45.0 13.0001, 45.0 13.0), (45.0 13.0, 45.0001 13.0, 45.0001 13.0001, 45.0 13.0001, 45.0 13.0))\n</code></pre>"},{"location":"user_manual/03-Working-with-Geometries/#geometries-from-other-relation-types","title":"Geometries from other relation types","text":"<p>OSM has many other relation types apart from the area types. pyosmium has no special support for other relation types yet. You need to manually assemble geometries by collecting the geometries of the members.</p>"},{"location":"user_manual/03-Working-with-Geometries/#geometry-factories","title":"Geometry Factories","text":"<p>pyosmium has a number of geometry factories to make it easier to convert an OSM object to well known geometry formats. To use them, instantiate the factory once and then hand in the OSM object to one of the create functions. A code snippet that converts all objects into WKT format looks approximately like that:</p> <p>Example</p> <pre><code>fab = osmium.geom.WKTFactory()\n\nfor o in osmium.FileProcessor('../data/buildings.opl').with_areas():\n    if o.is_node():\n        wkt = fab.create_point(o.location)\n    elif o.is_way() and not o.is_closed():\n        wkt = fab.create_linestring(o.nodes)\n    elif o.is_area():\n        wkt = fab.create_multipolygon(o)\n    else:\n        wkt = None # ignore relations\n</code></pre> <p>There are factories for GeoJSON (<code>osmium.geom.GeoJSONFactory</code>), well-known text (<code>osmium.geom.WKTFactory</code>) and well-known binary (<code>osmium.geom.WKBFactory</code>) formats.</p>"},{"location":"user_manual/03-Working-with-Geometries/#python-geo-interface","title":"Python Geo Interface","text":"<p>If you want to process the geometries with Python libraries like shapely<sup>1</sup> or GeoPandas, then the standardized geo_interface format can come in handy.</p> <p>pyosmium has a special filter GeoInterfaceFilter which enhances pyosmium objects with a <code>geo_interface</code> attribute. This allows libraries that support this interface to directly consume the OSM objects. The GeoInterfaceFilter needs location information to create the geometries. Don't forget to add <code>with_locations()</code> and/or <code>with_areas()</code> to the FileProcessor.</p> <p>Here is an example that computes the total length of highways using the geometry functions of shapely:</p> <p>Example</p> Code <pre><code>from shapely.geometry import shape\n\ntotal = 0.0\nfor o in osmium.FileProcessor('liechtenstein.osm.pbf').with_locations().with_filter(osmium.GeoHandler()):\n    if o.is_way() and 'highway' in o.tags:\n        # Shapely has only support for Features starting from version 2.1,\n        # so lets cheat a bit here.\n        geom = shape(o.__geo_interface__['geometry'])\n        # Length is computed in WGS84 projection, which is practically meaningless.\n        # Lets pretend we didn't notice, it is an example after all.\n        total += geom.length\n\nprint(\"Total length:\", total)\n</code></pre> Output <pre><code>Total length: 14.58228287312081\n</code></pre> <p>For an example on how to use the Python Geo Interface together with GeoPandas, have a look at the Visualisation Recipe.</p>"},{"location":"user_manual/03-Working-with-Geometries/#location-storage","title":"Location Storage","text":"<p>See the Osmium manual for the different types of location storage.</p> <ol> <li> <p>Shapely only received full support for geo_interface geometries with   features in version 2.1. For older versions create WKT geometries as   explained above and create Shapely geometries from that.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_manual/04-Working-with-Filters/","title":"Pre-Filtering Input Data","text":"<p>When processing an OSM file, it is often only a very small part of the objects the script really needs to see and process. Say, you are interested in the road network, then the millions of buildings in the file could easily be skipped over. This is the task of filters. They provide a fast and performance-efficient way to pre-process or skip over data before it is processed within the Python code.</p>"},{"location":"user_manual/04-Working-with-Filters/#how-filters-work","title":"How filters work","text":"<p>Filters can be added to a FileProcessor with the <code>with_filter()</code> function. An arbitrary number of filters can be added to the processor. Simply call the functions as many times as needed. The filters will be executed in the order they have been added. If any of the filters marks the object for removal, the object is immediately dropped and the next object from the file is processed.</p> <p>Filters can have side effects. That means that a filter may add additional attributes to the OSM object it processes and these attributes will be visible for subsequent filters and in the Python processing code. For example, the GeoInterfaceFilter adds a Python <code>__geo_interface__</code> attribute to the object.</p> <p>Filters can be restricted to process only certain types of OSM objects. If an OSM object doesn't have the right type, the filter will be skipped over as if it wasn't defined at all. To restrict the types, call the <code>enable_for()</code> function.</p> <p>Here is an example of a FileProcessor where only place nodes and boundary ways and relations are iterated through:</p> <p>Example</p> <pre><code>fp = osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\\n           .with_filter(osmium.filter.KeyFilter('place').enable_for(osmium.osm.NODE))\\\n           .with_filter(osmium.filter.KeyFilter('boundary').enable_for(osmium.osm.WAY | osmium.osm.RELATION))\n</code></pre>"},{"location":"user_manual/04-Working-with-Filters/#fallback-processing","title":"Fallback Processing","text":"<p>Once an object has been filtered, the default behaviour of the FileProcessor is to simply drop the object. Sometimes it can be useful to do something different with the object. For example, when you want to change some tags in a file and then write the data out again, then you'd usually want to filter out the objects that are not to be modified. However, you wouldn't want to drop them completely but write the unmodified object out. For such cases it is possible to set a fallback handler for filtered objects using the <code>handler_for_filtered()</code> function.</p> <p>The file writer can become a fallback handler for the file processor. The next chapter Handlers will show how to write a custom handler that can be used in this function.</p>"},{"location":"user_manual/04-Working-with-Filters/#built-in-filters","title":"Built-in Filters","text":"<p>The following section shortly describes the filters that are built into pyosmium.</p>"},{"location":"user_manual/04-Working-with-Filters/#emptytagfilter","title":"EmptyTagFilter","text":"<p>This filter removes all objects that have no tags at all. Most of the nodes in an OSM files fall under this category. So even when you don't want to apply any other filters, this one can make a huge difference in processing time:</p> <p>Example</p> Code <p><pre><code>print(\"Total number of objects:\",\n      sum(1 for o in osmium.FileProcessor('liechtenstein.osm.pbf')))\n\nprint(\"Total number of tagged objects:\",\n      sum(1 for o in osmium.FileProcessor('liechtenstein.osm.pbf')\n                           .with_filter(osmium.filter.EmptyTagFilter())))\n</code></pre> === Output <pre><code>Total number of objects: 340175\nTotal number of tagged objects: 49645\n</code></pre></p>"},{"location":"user_manual/04-Working-with-Filters/#entityfilter","title":"EntityFilter","text":"<p>The Entity filter only lets through objects of the selected type:</p> <p>Example</p> Code <pre><code>print(\"Total number of objects:\",\n      sum(1 for o in osmium.FileProcessor('../data/liechtenstein.osm.pbf')))\n\nprint(\"Of which are nodes:\",\n      sum(1 for o in osmium.FileProcessor('../data/liechtenstein.osm.pbf')\n                           .with_filter(osmium.filter.EntityFilter(osmium.osm.NODE))))\n</code></pre> Output <pre><code>Total number of objects: 340175\nOf which are nodes: 306700\n</code></pre> <p>On the surface, the filter is very similar to the entity selector that can be passed to the FileProcessor. In fact, it would be much faster to count the nodes using the entity selector:</p> <p>Example</p> <pre><code>print(\"Of which are nodes:\",\n      sum(1 for o in osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.NODE)))\n</code></pre> Output <pre><code>Of which are nodes: 306700\n</code></pre> <p>However, the two implementations use different mechanism to drop the nodes. When the entity selector in the FileProcessor is used like in the second example, then only the selected entities are read from the file. In our example, the file reader would skip over the ways and relations completely. When the entity filter is used, then the entities are only dropped when they get to the filter. Most importantly, the objects will still be visible to any filters applied before the entity filter.</p> <p>This can become of some importance when working with geometries. Lets say we can to compute the length of all highways in our file. You will remember from the last chapter about Working with Geometries that it is necessary to enable the location cache in order to be able to get the geometries of the road:</p> <p>Example</p> Code <pre><code>total = 0.0\n\nfor o in osmium.FileProcessor('../data/liechtenstein.osm.pbf')\\\n    .with_locations()\\\n    .with_filter(osmium.filter.EntityFilter(osmium.osm.WAY)):\n    if 'highway' in o.tags:\n        total += osmium.geom.haversine_distance(o.nodes)\n\nprint(f'Total length of highways is {total/1000} km.')\n</code></pre> Output <pre><code>Total length of highways is 1350.8030544343883 km.\n</code></pre> <p>The location cache needs to see all nodes in order to record their locations. This would not happen if the file reader skips over the nodes. It is therefore imperative to use the entity filter here. In fact, pyosmium will refuse to run when nodes are not enabled in a FileProcessor with location caching:</p> <p>Bad example</p> Code <pre><code>for o in osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.WAY).with_locations():\n    if 'highway' in o.tags:\n        osmium.geom.haversine_distance(o.nodes)\n</code></pre> Output <pre><code>---------------------------------------------------------------------------\n\nRuntimeError                              Traceback (most recent call last)\n\nCell In[14], line 1\n----&gt; 1 for o in osmium.FileProcessor('../data/liechtenstein.osm.pbf', osmium.osm.WAY).with_locations():\n      2     if 'highway' in o.tags:\n      3         osmium.geom.haversine_distance(o.nodes)\n\n\nFile ~/osm/dev/pyosmium/build/lib.linux-x86_64-cpython-311/osmium/file_processor.py:46, in FileProcessor.with_locations(self, storage)\n     42 \"\"\" Enable caching of node locations. This is necessary in order\n     43     to get geometries for ways and relations.\n     44 \"\"\"\n     45 if not (self._entities &amp; osmium.osm.NODE):\n---&gt; 46     raise RuntimeError('Nodes not read from file. Cannot enable location cache.')\n     47 if isinstance(storage, str):\n     48     self._node_store = osmium.index.create_map(storage)\n\n\nRuntimeError: Nodes not read from file. Cannot enable location cache.\n</code></pre>"},{"location":"user_manual/04-Working-with-Filters/#keyfilter","title":"KeyFilter","text":"<p>This filter only lets pass objects where its list of tags has any of the keys given in the arguments of the filter.</p> <p>If you want to ensure that all of the keys are present, use the KeyFilter multiple times:</p> <p>Example</p> <pre><code>print(\"Objects with 'building' _or_ 'amenity' key:\",\n      sum(1 for o in osmium.FileProcessor('../data/liechtenstein.osm.pbf')\n                           .with_filter(osmium.filter.KeyFilter('building', 'amenity'))))\n\nprint(\"Objects with 'building' _and_ 'amenity' key:\",\n      sum(1 for o in osmium.FileProcessor('../data/liechtenstein.osm.pbf')\n                           .with_filter(osmium.filter.KeyFilter('building'))\n                           .with_filter(osmium.filter.KeyFilter('amenity'))))\n</code></pre>"},{"location":"user_manual/04-Working-with-Filters/#tagfilter","title":"TagFilter","text":"<p>This filter works exactly the same as the KeyFilter, only it looks for the presence of whole tags (key and value) in the tag list of the object.</p>"},{"location":"user_manual/04-Working-with-Filters/#idfilter","title":"IdFilter","text":"<p>This filter takes an iterable of numbers and lets only pass objects that have an ID that matches the list. This filter is particularly useful when doing a two-stage processing, where in the first stage the file is scanned for objects that are of interest (for example, members of certain relations) and then in the second stage these objects are read from the file. You pretty much always want to use this filter in combination with the <code>enable_for()</code> function to restrict it to a certain object type.</p> <p>In its purest form, the filter could be used to search for a single object in a file:</p> <p>Example</p> <pre><code>fp = osmium.FileProcessor('../data/buildings.opl')\\\n           .with_filter(osmium.filter.EntityFilter(osmium.osm.WAY))\\\n           .with_filter(osmium.filter.IdFilter([1]))\n\nfor o in fp:\n    print(o)\n</code></pre> <p>However, in practise it is a very expensive way to find a single object. Remember that the entire file will be scanned by the FileProcessor just to find that one piece of information.</p>"},{"location":"user_manual/04-Working-with-Filters/#custom-python-filters","title":"Custom Python Filters","text":"<p>It is also possible to define a custom filter in Python. Most of the time this is not very useful because calling a filter implemented in Python is just as expensive as returning the OSM object to Python and doing the processing then. However, it can be useful when the FileProcessor is used as an Iterable input to other libraries like GeoPandas.</p> <p>A Python filter needs to be implemented as a class that looks exactly like a Handler class: for each type that should be handled by the filter, implement a callback function <code>node()</code>, <code>way()</code>, <code>relation()</code>, <code>area()</code> or <code>changeset()</code>. If a callback for a certain type is not implemented, then the object type will automatically pass through the filter. The callback function needs to return either 'True', when the object should be filtered out, or 'False' when it should pass through.</p> <p>Here is a simple example of a filter that filters out all nodes that are older than 2020:</p> <p>Example</p> <pre><code>import datetime as dt\n\nclass DateFilter:\n\n    def node(self, n):\n        return n.timestamp &lt; dt.datetime(2020, 1, 1, tzinfo=dt.UTC)\n\n\nprint(\"Total number of objects:\",\n      sum(1 for o in osmium.FileProcessor('../data/liechtenstein.osm.pbf')))\n\nprint(\"Without nodes older than 2020:\",\n      sum(1 for o in osmium.FileProcessor('../data/liechtenstein.osm.pbf')\n                           .with_filter(DateFilter())))\n</code></pre>"},{"location":"user_manual/05-Working-with-Handlers/","title":"Handler-based Processing","text":"<p>All examples so far have used the FileProcessor for reading files. It provides an iterative way of working through the data, which comes quite natural to a Python programmer. This chapter shows a different way of processing a file. It shows how to create one or more handler classes and apply those to an input file.</p> <p>Note: handler classes used to be the only way of processing data in older pyosimum versions. You may therefore find them in many tutorials and examples. There is no disadvantage in using FileProcessors instead. Handlers simply provide a different syntax for achieving a similar goal.</p>"},{"location":"user_manual/05-Working-with-Handlers/#the-handler-object-and-osmiumapply","title":"The handler object and osmium.apply","text":"<p>A pyosmium handler object is simply a Python object that implements callbacks to handle the different types of entities (<code>node</code>, <code>way</code>, <code>relation</code>, <code>area</code>, <code>changeset</code>). Usually you would define a class with your handler functions and instantiate it. A complete handler class that prints out each object in the file would look like this:</p> <p>Example</p> <pre><code>class PrintHandler:\n    def node(self, n):\n        print(n)\n\n    def way(self, w):\n        print(w)\n\n    def relation(self, r):\n        print(r)\n\n    def area(self, a):\n        print(a)\n\n    def changeset(self, c):\n        print(c)\n</code></pre> <p>Such a handler is applied to an OSM file with the function <code>osmium.apply()</code>. The function takes a single file as an argument and then an arbitrary number of handlers:</p> <p>Example</p> Code <pre><code>import osmium\n\nmy_handler = PrintHandler()\n\nosmium.apply('buildings.opl', my_handler)\n</code></pre> Output <pre><code>n1: location=45.0000000/13.0000000 tags={}\nn2: location=45.0001000/13.0000000 tags={}\nn3: location=45.0001000/13.0001000 tags={}\nn4: location=45.0000000/13.0001000 tags={entrance=yes}\nn11: location=45.0000100/13.0000100 tags={}\nn12: location=45.0000500/13.0000100 tags={}\nn13: location=45.0000500/13.0000500 tags={}\nn14: location=45.0000100/13.0000500 tags={}\nw1: nodes=[1,2,3,4,1] tags={amenity=restaurant}\nw2: nodes=[11,12,13,14,11] tags={}\nr1: members=[w1,w2], tags={type=multipolygon,building=yes}\n</code></pre>"},{"location":"user_manual/05-Working-with-Handlers/#using-filters-with-apply","title":"Using filters with apply","text":"<p>Filter functions are also recognised as handlers by the apply functions. They have the same effect as when used in FileProcessors: when they signal to filter out an object, then the processing is stopped for that object and the next object is processed. You can arbitrarily mix filters and custom-made handlers. They are sequentially executed in the order in which they appear in the apply function:</p> <p>Example</p> <pre><code>osmium.apply('buildings.opl',\n             osmium.filter.EntityFilter(osmium.osm.RELATION),\n             my_handler,\n             osmium.filter.KeyFilter('route')),\n             my_other_handler\n</code></pre>"},{"location":"user_manual/05-Working-with-Handlers/#the-osmiumsimplehandler-class","title":"The <code>osmium.SimpleHandler</code> class","text":"<p>The <code>apply</code> function is a very low-level function for processing. It will only apply the handler functions to the input and be done with it. It will in particular not care about providing the necessary building blocks for geometry processing. If you need to work with geometries, you can derive your handler class from  <code>osmium.SimpleHandler</code>. This mix-in class adds two convenience functions to your handler : <code>apply_file()</code> and <code>apply_buffer()</code>. These functions apply the handler itself to a file or buffer but come with additional parameter to enable location. If the handler implements an <code>area</code> callback, then they automatically enable area processing as well.</p>"},{"location":"user_manual/06-Writing-Data/","title":"Writing Data","text":"<p>pyosmium can also be used to write OSM files. It offers different writer classes which support creating referentially correct files.</p>"},{"location":"user_manual/06-Writing-Data/#basic-writer-usage","title":"Basic writer usage","text":"<p>All writers are created by instantiating them with the name of the file to write to.</p> <p>Example</p> <pre><code>writer = osmium.SimpleWriter('my_extra_data.osm.pbf')\n</code></pre> <p>The format of the output file is usually determined through the file prefix. pyosmium will refuse to overwrite any existing files. Either make sure to delete the files before instantiating a writer or use the parameter <code>overwrite=true</code>.</p> <p>Once a writer is instantiated, one of the <code>add*</code> functions can be used to add an OSM object to the file. You can either use one of the <code>add_node/way/relation</code> functions to force writing a specific type of object or use the generic <code>add</code> function, which will try to determine the object type. The OSM objects are directly written out in the order in which they are given to the writer object. It is your responsibility as a user to make sure that the order is correct with respect to the conventions for object order.</p> <p>After writing all data the writer needs to be closed using the <code>close()</code> function. It is usually easier to use a writer as a context manager.</p> <p>Here is a complete example for a script that converts a file from OPL format to PBF format:</p> <p>Example</p> <pre><code>with osmium.SimpleWriter('buildings.osm.pbf') as  writer:\n    for o in osmium.FileProcessor('buildings.opl'):\n        writer.add(o)\n</code></pre>"},{"location":"user_manual/06-Writing-Data/#writing-modified-objects","title":"Writing modified objects","text":"<p>In the example above an OSM object from an input file was written out directly without modifications. Writers can accept OSM nodes, ways and relations that way. However, usually you want to modify some of the data in the object before writing it out again. Use the <code>replace()</code> function to create a mutable version of the object with the given parameters replaced.</p> <p>Say you want to create a copy of a OSM file with all <code>source</code> tags removed:</p> <p>Example</p> <pre><code>with osmium.SimpleWriter('buildings.osm.pbf') as  writer:\n    for o in osmium.FileProcessor('buildings.opl'):\n        if 'source' in tags:\n            new_tags = dict(o.tags) # make a copy of the tags\n            del new_tags['source']\n            writer.add(o.replace(tags=new_tags))\n        else:\n            # No source tag. Write object out as-is.\n            writer.add(o)\n</code></pre>"},{"location":"user_manual/06-Writing-Data/#writing-custom-objects","title":"Writing custom objects","text":"<p>You can also write data that is not based on OSM input data at all. The write functions will accept any Python object that mimics the attributes of a node, way or relation.</p>"},{"location":"user_manual/06-Writing-Data/#writer-types","title":"Writer types","text":"<p>pyosmium implements three different writer classes: the basic SimpleWriter and the two reference-completing writers ForwardReferenceWriter and BackReferenceWriter.</p>"},{"location":"user_manual/07-Input-Formats-And-Other-Sources/","title":"Input Formats and Other Sources","text":"<p>pyosmium can read OSM data from different sources and in different formats.</p>"},{"location":"user_manual/07-Input-Formats-And-Other-Sources/#supported-file-formats","title":"Supported file formats","text":"<p>pyosmium has built-in support for the most common OSM data formats as well as formats specific to libosmium. The format to use is usually determined by the suffix of the file name. The following table gives an overview over the suffix recognised, the corresponding format and if the formats support reading and/or writing.</p> Suffix Reading Writing Format <code>.pbf</code> protobuf-based PBF format <code>.osm</code> Original XML format <code>.xml</code> \u2060 \u2060 \u2060 <code>.o5m</code> Custom format created by the osmc tools <code>.opl</code> Osmium's line based text format OPL <code>.debug</code> a verbose human-readable format <code>.ids</code> Text format only containing the object IDs <p>All formats also support compression with gzip (suffix <code>.gz</code>) and bzip2 (suffix <code>.bz2</code>) with the exception of the PBF format.</p> <p>The suffixes may be further prefixed by three subtypes:</p> <ul> <li><code>.osm</code> - A simple OSM data file.   Each object appears at most with one version in the file.</li> <li><code>.osc</code> - An OSM change file.   Multiple versions of an object may appear in the file. The file is   usually not reference-complete.</li> <li><code>.osh</code> - An OSM history file.   Objects appear with all available versions in the file. The file is   usually reference-complete.</li> </ul> <p>Thus the type <code>.osh.xml.bz2</code> would be an OSM history file in XML format that has been compressed using the bzip2 algorithm.</p> <p>If you have file inputs where the suffix differs from the internal format, the file type can be explicitly set by instantiating an osmium.io.File object. It takes an optional format parameter which then must contain the suffix notation of the desired file format.</p> <p>Example</p> <p>This example forces the given input text file to be read as OPL.</p> <pre><code>fp = osmium.FileProcessor(osmium.io.File('assorted.txt', 'opl'))\n</code></pre>"},{"location":"user_manual/07-Input-Formats-And-Other-Sources/#using-standard-input-and-output","title":"Using standard input and output","text":"<p>The special file name <code>-</code> can be used to read from standard input or write to standard output.</p> <p>When reading data, use a <code>File</code> object to specify the file format. With the SimpleReader, you need to use the parameter <code>filetype</code>.</p> <p>Example</p> <p>This code snipped dumps all ids of your input file to the console.</p> <pre><code>with osmium.SimpleWriter('-', filetype='ids') as writer:\n    for o in osmium.FileProcessor('test.pbf'):\n        writer.add(o)\n</code></pre>"},{"location":"user_manual/07-Input-Formats-And-Other-Sources/#reading-from-buffers","title":"Reading from buffers","text":"<p>pyosmium can also read data from a in-memory byte buffer. Simply wrap the buffer in a osmium.io.FileBuffer. The file format always needs to be explicitly given.</p> <p>Example</p> <p>Reading from a buffer comes in handy when loading OSM data from a URL. This example computes statistics over data downloaded from an URL.</p> <pre><code>import urllib.request as urlrequest\n\ndata = urlrequest.urlopen('https://example.com/some.osm.gz').read()\n\ncounter = {'n': 0, 'w': 0, 'r': 0}\n\nfor o in osmium.FileProcessor(osmium.io.FileBuffer(data, 'osm.gz')):\n    counter[o.type_str()] += 1\n\nprint(\"Nodes: %d\" % counter['n'])\nprint(\"Ways: %d\" % counter['w'])\nprint(\"Relations: %d\" % counter['r'])\n</code></pre>"},{"location":"user_manual/08-Working-With-Change-Files/","title":"Working With Change Files","text":"<p>OpenStreetMap produces two kinds of data, full data files and diff files with updates. This chapter explains how to handle diff files.</p>"},{"location":"user_manual/09-Working-With-History-Files/","title":"Working With History Files","text":"<p>An OSM data file usually contains data of a snapshot of the OpenStreetMap database at a certain point in time. The full database contains even more data. It has all the changes that were ever made. The full version of the database with the complete history is contained in so called history files. They do require some special attention when processing.</p>"},{"location":"user_manual/10-Replication-Tools/","title":"Replication Tools","text":"<p>OpenStreetMap is a database that is constantly extended and updated. When you download the planet or an extract of it, you only get a snapshot of the database at a given point in time. To keep up-to-date with the development of OSM, you either need to download a new snapshot or you can update your existing data from change files published along with the planet file. Pyosmium ships with two tools that help you to process change files: <code>pyosmium-get-changes</code> and <code>pyosmium-up-to-date</code>.</p> <p>This section explains the basics of OSM change files and how to use Pyosmium's tools to keep your data up to date.</p>"},{"location":"user_manual/10-Replication-Tools/#about-change-files","title":"About change files","text":"<p>Regular change files are published for the planet and also by some extract services. These change files are special OSM data files containing all changes to the database in a regular interval. Change files are not referentially complete. That means that they only contain OSM objects that have changed but not necessarily all the objects that are referenced by the changed objects. Because of that change file are rarely useful on their own. But they can be used to update an existing snapshot of OSM data.</p>"},{"location":"user_manual/10-Replication-Tools/#getting-change-files","title":"Getting change files","text":"<p>There are multiple sources for OSM change files available:</p> <ul> <li> <p>https://planet.openstreetmap.org/replication    is the official source    for planet-wide updates. There are change files for    minutely, hourly and daily intervals available.</p> </li> <li> <p>Geofabrik offers daily change files    for all its updates. See the extract page for a link to the replication URL.    Note that change files go only about 3 months back. Older files are deleted.</p> </li> <li> <p>download.openstreetmap.fr offers    minutely change files    for all its extracts.</p> </li> </ul> <p>For other services also check out the list of providers on the OSM wiki.</p>"},{"location":"user_manual/10-Replication-Tools/#updating-a-planet-or-extract","title":"Updating a planet or extract","text":"<p>If you have downloaded the full planet or obtain a PBF extract file from one of the sites which offer a replication service, then updating your OSM file can be as easy as:</p> <pre><code>pyosmium-up-to-date &lt;osmfile.osm.pbf&gt;\n</code></pre> <p>This finds the right replication source and file to start with, downloads changes and updates the given file with the data. You can repeat this command whenever you want to have newer data. The command automatically picks up at the same point where it left off after the previous update.</p>"},{"location":"user_manual/10-Replication-Tools/#choosing-the-replication-source","title":"Choosing the replication source","text":"<p>OSM files in PBF format are able to save the replication source and the current status on their own. That is why pyosmium-up-to-date is able to automatically do the right thing. If you want to switch the replication source or have a file that does not have replication information, you need to bootstrap the update process and manually point <code>pyosmium-up-to-date</code> to the right service:</p> <pre><code>pyosmium-up-to-date --ignore-osmosis-headers --server &lt;replication URL&gt; &lt;osmfile.osm.pbf&gt;\n</code></pre> <p><code>pyosmium-up-to-date</code> automatically finds the right sequence ID to use by looking at the age of the data in your OSM file. It updates the file and stores the new replication source in the file. The additional parameters are then not necessary anymore for subsequent updates.</p> <p>Tip</p> <p>Always use the PBF format to store your data. Other format do not support to save the replication information. pyosmium-up-to-date is still able to update these kind of files if you manually point to the replication server but the process is always more costly because it needs to find the right starting point for updates first.</p>"},{"location":"user_manual/10-Replication-Tools/#updating-larger-amounts-of-data","title":"Updating larger amounts of data","text":"<p>When used without any parameters, pyosmium downloads at a maximum about 1GB of changes. That corresponds to about 3 days of planet-wide changes. You can increase the amount using the additional <code>--size</code> parameter:</p> <pre><code>pyosmium-up-to-date --size=10000 planet.osm.pbf\n</code></pre> <p>This would download about 10GB or 30 days of change data. If your OSM data file is older than that, downloading the full file anew is likely going to be faster.</p> <p><code>pyosmium-up-to-date</code> uses return codes to signal if it has downloaded all available updates. A return code of 0 means that it has downloaded and applied all available data. A return code of 1 indicates that it has applied some updates but more are available.</p> <p>A minimal script that updates a file until it is really up-to-date with the replication source would look like this:</p> <pre><code>status=1  # we want more data\nwhile [ $status -eq 1 ]; do\n    pyosmium-up-to-date planet.osm.pbf\n    # save the return code\n    status=$?\ndone\n</code></pre>"},{"location":"user_manual/10-Replication-Tools/#creating-change-files-for-updating-databases","title":"Creating change files for updating databases","text":"<p>There are quite a few tools that can import OSM data into databases, for example osm2pgsql, imposm or Nominatim. These tools often can use change files to keep their database up-to-date. pyosmium can be used to create the appropriate change files. This is slightly more involved than updating a file.</p>"},{"location":"user_manual/10-Replication-Tools/#preparing-the-state-file","title":"Preparing the state file","text":"<p>Before downloading the updates, you need to find out with which sequence number to start. The easiest way to remember your current status is to save the number in a file. pyosmium can then read and update the file for you.</p>"},{"location":"user_manual/10-Replication-Tools/#method-1-starting-from-the-import-file","title":"Method 1: Starting from the import file","text":"<p>If you still have the OSM file you used to set up your database, then create a state file as follows:</p> <pre><code>pyosmium-get-changes -O &lt;osmfile.osm.pbf&gt; -f sequence.state -v\n</code></pre> <p>Note that there is no output file yet. This creates a new file <code>sequence.state</code> with the sequence ID where updates should start and prints the URL of the replication service to use.</p>"},{"location":"user_manual/10-Replication-Tools/#method-2-starting-from-a-date","title":"Method 2: Starting from a date","text":"<p>If you do not have the original OSM file anymore, then a good strategy is to look for the date of the newest node in the database to find the snapshot date of your database. Find the highest node ID, then look up the date for version 1 on the OSM website. For example the date for node 2367234 can be found at https://www.openstreetmap.org/api/0.6/node/23672341/1 Find and copy the <code>timestamp</code> field. Then create a state file using this date:</p> <pre><code>pyosmium-get-changes -D 2007-01-01T14:16:21Z -f sequence.state -v\n</code></pre> <p>As before, this creates a new file <code>sequence.state</code> with the sequence ID where updates should start and prints the URL of the replication service to use.</p>"},{"location":"user_manual/10-Replication-Tools/#creating-a-change-file","title":"Creating a change file","text":"<p>Now you can create change files using the state:</p> <pre><code>pyosmium-get-changes --server &lt;replication server&gt; -f sequence.state -o newchange.osc.gz\n</code></pre> <p>This downloads the latest changes from the server, saves them in the file <code>newchange.osc.gz</code> and updates your state file. <code>&lt;replication server&gt;</code> is the URL that was printed when you set up the state file. The parameter can be omitted when you use minutely change files from openstreetmap.org. This simplifies multiple edits of the same element into the final change. If you want to retain the full version history specify <code>--no-deduplicate</code>.</p> <p><code>pyosmium-get-changes</code> loads only about 100MB worth of updates at once (about 8 hours of planet updates). If you want more, then add a <code>--size</code> parameter.</p>"},{"location":"user_manual/10-Replication-Tools/#continuously-updating-a-database","title":"Continuously updating a database","text":"<p><code>pyosmium-get-changes</code> emits special return codes that can be used to set up a script that continuously fetches updates and applies them to a database. The important error codes are:</p> <ul> <li>0 - changes successfully downloaded and new change file created</li> <li>3 - no new changes are available from the server</li> </ul> <p>All other error codes indicate fatal errors.</p> <p>A simple shell script can look like this:</p> <pre><code>while true; do\n  # pyosmium-get-changes would not overwrite an existing change file\n  rm -f newchange.osc.gz\n  # get the next batch of changes\n  pyosmium-get-changes -f sequence.state -o newchange.osc.gz\n  # save the return code\n  status=$?\n\n  if [ $status -eq 0 ]; then\n    # apply newchange.osc.gz here\n    ....\n  elif [ $status -eq 3 ]; then\n    # No new data, so sleep for a bit\n    sleep 60\n  else\n    echo \"Fatal error, stopping updates.\"\n    exit $status\ndone\n</code></pre>"}]}